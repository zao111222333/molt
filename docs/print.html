<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Molt Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Molt: More Or Less Tcl</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tcl_comp.html"><strong aria-hidden="true">1.1.</strong> Tcl Compatibility</a></li><li class="chapter-item expanded "><a href="changes.html"><strong aria-hidden="true">1.2.</strong> Annotated Change Log</a></li></ol></li><li class="chapter-item expanded "><a href="cmdline/cmdline.html"><strong aria-hidden="true">2.</strong> Molt Command Line Tool</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cmdline/molt_shell.html"><strong aria-hidden="true">2.1.</strong> molt shell</a></li><li class="chapter-item expanded "><a href="cmdline/molt_test.html"><strong aria-hidden="true">2.2.</strong> molt test</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cmdline/test_commands/test.html"><strong aria-hidden="true">2.2.1.</strong> test</a></li></ol></li><li class="chapter-item expanded "><a href="cmdline/molt_bench.html"><strong aria-hidden="true">2.3.</strong> molt bench</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cmdline/bench_commands/benchmark.html"><strong aria-hidden="true">2.3.1.</strong> benchmark</a></li><li class="chapter-item expanded "><a href="cmdline/bench_commands/measure.html"><strong aria-hidden="true">2.3.2.</strong> measure</a></li><li class="chapter-item expanded "><a href="cmdline/bench_commands/ok.html"><strong aria-hidden="true">2.3.3.</strong> ok</a></li><li class="chapter-item expanded "><a href="cmdline/bench_commands/ident.html"><strong aria-hidden="true">2.3.4.</strong> ident</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ref/reference.html"><strong aria-hidden="true">3.</strong> Molt Command Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref/append.html"><strong aria-hidden="true">3.1.</strong> append</a></li><li class="chapter-item expanded "><a href="ref/array.html"><strong aria-hidden="true">3.2.</strong> array</a></li><li class="chapter-item expanded "><a href="ref/assert_eq.html"><strong aria-hidden="true">3.3.</strong> assert_eq</a></li><li class="chapter-item expanded "><a href="ref/break.html"><strong aria-hidden="true">3.4.</strong> break</a></li><li class="chapter-item expanded "><a href="ref/catch.html"><strong aria-hidden="true">3.5.</strong> catch</a></li><li class="chapter-item expanded "><a href="ref/continue.html"><strong aria-hidden="true">3.6.</strong> continue</a></li><li class="chapter-item expanded "><a href="ref/dict.html"><strong aria-hidden="true">3.7.</strong> dict</a></li><li class="chapter-item expanded "><a href="ref/error.html"><strong aria-hidden="true">3.8.</strong> error</a></li><li class="chapter-item expanded "><a href="ref/exit.html"><strong aria-hidden="true">3.9.</strong> exit</a></li><li class="chapter-item expanded "><a href="ref/expr.html"><strong aria-hidden="true">3.10.</strong> expr</a></li><li class="chapter-item expanded "><a href="ref/for.html"><strong aria-hidden="true">3.11.</strong> for</a></li><li class="chapter-item expanded "><a href="ref/foreach.html"><strong aria-hidden="true">3.12.</strong> foreach</a></li><li class="chapter-item expanded "><a href="ref/global.html"><strong aria-hidden="true">3.13.</strong> global</a></li><li class="chapter-item expanded "><a href="ref/if.html"><strong aria-hidden="true">3.14.</strong> if</a></li><li class="chapter-item expanded "><a href="ref/incr.html"><strong aria-hidden="true">3.15.</strong> incr</a></li><li class="chapter-item expanded "><a href="ref/info.html"><strong aria-hidden="true">3.16.</strong> info</a></li><li class="chapter-item expanded "><a href="ref/join.html"><strong aria-hidden="true">3.17.</strong> join</a></li><li class="chapter-item expanded "><a href="ref/lindex.html"><strong aria-hidden="true">3.18.</strong> lindex</a></li><li class="chapter-item expanded "><a href="ref/list.html"><strong aria-hidden="true">3.19.</strong> list</a></li><li class="chapter-item expanded "><a href="ref/llength.html"><strong aria-hidden="true">3.20.</strong> llength</a></li><li class="chapter-item expanded "><a href="ref/proc.html"><strong aria-hidden="true">3.21.</strong> proc</a></li><li class="chapter-item expanded "><a href="ref/puts.html"><strong aria-hidden="true">3.22.</strong> puts</a></li><li class="chapter-item expanded "><a href="ref/rename.html"><strong aria-hidden="true">3.23.</strong> rename</a></li><li class="chapter-item expanded "><a href="ref/return.html"><strong aria-hidden="true">3.24.</strong> return</a></li><li class="chapter-item expanded "><a href="ref/set.html"><strong aria-hidden="true">3.25.</strong> set</a></li><li class="chapter-item expanded "><a href="ref/source.html"><strong aria-hidden="true">3.26.</strong> source</a></li><li class="chapter-item expanded "><a href="ref/string.html"><strong aria-hidden="true">3.27.</strong> string</a></li><li class="chapter-item expanded "><a href="ref/throw.html"><strong aria-hidden="true">3.28.</strong> throw</a></li><li class="chapter-item expanded "><a href="ref/time.html"><strong aria-hidden="true">3.29.</strong> time</a></li><li class="chapter-item expanded "><a href="ref/unset.html"><strong aria-hidden="true">3.30.</strong> unset</a></li><li class="chapter-item expanded "><a href="ref/while.html"><strong aria-hidden="true">3.31.</strong> while</a></li></ol></li><li class="chapter-item expanded "><a href="embed/overview.html"><strong aria-hidden="true">4.</strong> Extending and Embedding</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="embed/molt_value.html"><strong aria-hidden="true">4.1.</strong> The Molt Value Type</a></li><li class="chapter-item expanded "><a href="embed/molt_result.html"><strong aria-hidden="true">4.2.</strong> The MoltResult Type</a></li><li class="chapter-item expanded "><a href="embed/commands.html"><strong aria-hidden="true">4.3.</strong> Defining Commands</a></li><li class="chapter-item expanded "><a href="embed/eval.html"><strong aria-hidden="true">4.4.</strong> Evaluating Molt Code</a></li><li class="chapter-item expanded "><a href="embed/shell.html"><strong aria-hidden="true">4.5.</strong> Custom Shell Applications</a></li><li class="chapter-item expanded "><a href="embed/library.html"><strong aria-hidden="true">4.6.</strong> Molt Library Crates</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                        </div>

                        <h1 class="menu-title">The Molt Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="molt-forked"><a class="header" href="#molt-forked">Molt-forked</a></h1>
<p><a href="https://crates.io/crates/molt-forked"><img src="https://img.shields.io/crates/v/molt-forked.svg" alt="Crates.io" /></a></p>
<p>This is a forked version of <code>molt</code>, a embeddable TCL interpreter for Rust applications. The original repository is no longer actively maintained, and this version aims to continue its development, fix bugs, and add new features.</p>
<h2 id="new-in-molt-forked-041"><a class="header" href="#new-in-molt-forked-041">New in Molt-forked 0.4.1</a></h2>
<ul>
<li>The subcommands now is static, we can use <code>gen_subcommand!</code> macro to init SubCommand.</li>
</ul>
<h2 id="new-in-molt-forked-040"><a class="header" href="#new-in-molt-forked-040">New in Molt-forked 0.4.0</a></h2>
<ul>
<li>
<p>WASM runtime support, see demo at <a href="https://zao111222333.github.io/molt-forked/demo/">here</a>, the demo project is in <code>molt-wasm</code> and you can find that the size of compiled WASM binary is only ~600k.</p>
</li>
<li>
<p>Remove <code>ContextMap</code> and related attributes / function parameters in Interpreter. Now the definiton of Interpreter is <code>Interp&lt;Ctx&gt;</code> (with user-defined generic <code>Ctx</code>), we can access Interpreter's Context directly via <code>interp.context</code>.</p>
</li>
<li>
<p>The native commands now is static, we need to use <code>gen_command!</code> macro to init Command.</p>
<p>The benefit is that <code>molt-fork</code> can use <code>match</code> block to implement token matching, rather than <code>HashMap</code></p>
</li>
<li>
<p>New document (<a href="https://zao111222333.github.io/molt-forked">The Molt Book</a>, Code Description) is not unimplemented yet.</p>
</li>
</ul>
<h3 id="benchmark-result"><a class="header" href="#benchmark-result">Benchmark Result</a></h3>
<ul>
<li>
<p><strong>Command</strong>: <code>cd molt-app &amp;&amp; cargo run --release bench ../benchmarks/basic.tcl</code></p>
</li>
<li>
<p><strong>Platform</strong>: Intel Xeon 6348 CPU</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>molt-forked <code>0.4.0</code> (time unit in Nanos)</th><th>molt <code>0.3.2</code></th><th>Speedup (Ã—)</th><th>Benchmark</th></tr></thead><tbody>
<tr><td>89</td><td>208</td><td>2.34</td><td>ok-1.1 ok, no arguments</td></tr>
<tr><td>90</td><td>207</td><td>2.3</td><td>ok-1.2 ok, one argument</td></tr>
<tr><td>97</td><td>219</td><td>2.26</td><td>ok-1.3 ok, two arguments</td></tr>
<tr><td>119</td><td>209</td><td>1.76</td><td>ident-1.1 ident, simple argument</td></tr>
<tr><td>209</td><td>402</td><td>1.92</td><td>incr-1.1 incr a</td></tr>
<tr><td>158</td><td>311</td><td>1.97</td><td>set-1.1 set var value</td></tr>
<tr><td>201</td><td>348</td><td>1.73</td><td>list-1.1 list of six items</td></tr>
</tbody></table>
</div>
<hr />
<p>===================== Below is Origin Document =====================</p>
<hr />
<h1 id="molt-more-or-less-tcl"><a class="header" href="#molt-more-or-less-tcl">Molt: More Or Less Tcl</a></h1>
<p><strong>Molt 0.3.2</strong> is a minimal implementation of the TCL language for embedding in Rust apps
and for scripting Rust libraries.  Molt is intended to be:</p>
<ul>
<li>
<p><strong>Small in size.</strong> Embedding Molt shouldn't greatly increase the size of the
application.</p>
</li>
<li>
<p><strong>Small in language.</strong> <a href="http://tcl-lang.org">Standard TCL</a> has many features
intended for building entire software systems.  Molt is intentionally
limited to those needed for embedding.</p>
</li>
<li>
<p><strong>Small in dependencies.</strong> Including the Molt interpreter in your project shouldn't
drag in anything else--unless you ask for it.</p>
</li>
<li>
<p><strong>Easy to build.</strong> Building Standard TCL is non-trivial.  Embedding
Molt should be as simple as using any other crate.</p>
</li>
<li>
<p><strong>Easy to embed.</strong> Extending Molt with TCL commands that wrap Rust APIs should
be easy and simple.</p>
</li>
</ul>
<p>Hence, perfect compatibility with Standard TCL is explicitly not a goal.  Many
features will not be implemented at all (e.g., octal literals); and others may
be implemented somewhat differently where a clearly better alternative exists
(e.g., <code>-nocomplain</code> will always be the normal behavior).  In addition, Molt will
prefer Rust standards where appropriate.</p>
<p>On the other hand, Molt is meant to be TCL (more or less), not simply a
"Tcl-like language", so gratuitous differences are to be avoided.  One of the
goals of this document is to carefully delineate:</p>
<ul>
<li>The features that have not yet been implemented.</li>
<li>The features that likely will never be implemented.</li>
<li>Any small differences in behavior.</li>
<li>And especially, any features that have intentionally been implemented in
a different way.</li>
</ul>
<h2 id="what-molt-is-for"><a class="header" href="#what-molt-is-for">What Molt Is For</a></h2>
<p>Using Molt, you can:</p>
<ul>
<li>Create a shell interpreter for scripting and interactive testing of your Rust crates.</li>
<li>Provide your Rust applications with an interactive REPL for debugging and
administration.</li>
<li>Extend your Rust application with scripts provided at compile-time or at run-time.</li>
<li>Allow your users to script your applications and libraries.</li>
</ul>
<p>See the <a href="https://github.com/wduquette/molt-sample"><code>molt-sample</code> repo</a> for a sample Molt client
skeleton.</p>
<h2 id="new-in-molt-032"><a class="header" href="#new-in-molt-032">New in Molt 0.3.2</a></h2>
<p>Nothing, yet!  See the <a href="changes.html">Annotated Change Log</a> for the new features by version.</p>
<h2 id="coming-attractions"><a class="header" href="#coming-attractions">Coming Attractions</a></h2>
<p>At this point Molt is capable and robust enough for real work, though the Rust-level API is
not yet completely stable.  Standard Rust <code>0.y.z</code> semantic versioning applies: ".y" changes
can break the Rust-level API, ".z" changes will not.</p>
<ul>
<li>More TCL Commands</li>
<li>Testing improvements</li>
<li>Documentation improvements</li>
<li>Feature: Regex and Glob pattern matching by Molt commands</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcl-compatibility"><a class="header" href="#tcl-compatibility">Tcl Compatibility</a></h1>
<p>Molt is aiming at limited compatibility with TCL 8.x, the current stable version
of Standard TCL, as described <a href="overview.html">above</a>.  The development plan is as follows:</p>
<ul>
<li>Implement the complete Molt semantics
<ul>
<li>Core interpreter</li>
<li>Essential TCL commands</li>
<li>Robust and ergonomic Rust-level API for extending TCL in Rust</li>
<li>Related tools (e.g., TCL-level test harness)</li>
<li>Thorough and complete test suite (at both Rust and TCL levels)</li>
<li>Thorough documentation</li>
</ul>
</li>
<li>Optimize for speed
<ul>
<li>Ideally including byte-compilation</li>
</ul>
</li>
<li>Extend with new features as requested.</li>
</ul>
<p>Each TCL command provided standard by the Molt interpreter is documented in this
book with a complete <a href="./ref/reference.html">man page</a>.  A command's man page documents
the semantics of the command, and any temporary or permanent differences between it and the
similarly named command in <a href="http://tcl-lang.org">Standard TCL</a>.</p>
<p>The remainder of this section documents overall differences; see the
<a href="https://github.com/wduquette/molt">Molt README</a> for details on current
development.</p>
<p>Note that some of the features described as never to be implemented
could conceivably be added as extension crates.</p>
<h2 id="features-that-already-exist"><a class="header" href="#features-that-already-exist">Features that already exist</a></h2>
<p>See the <a href="./ref/reference.html">command reference</a> for the set of commands that
have already been implemented.  The current set of features includes:</p>
<p>At the TCL Level:</p>
<ul>
<li>Script execution</li>
<li>Procedure definition</li>
<li>Standard control structures (except the <code>switch</code> command)</li>
<li>Local and global variables, including associative arrays</li>
<li>Boolean and numeric expressions</li>
<li>Dictionaries</li>
<li>Many standard TCL commands</li>
<li>A modicum of introspection</li>
</ul>
<p>At the Rust Level:</p>
<ul>
<li>A clean and modular embedding API</li>
<li>The <code>Interp</code> struct (e.g., Standard TCL's Interp)
<ul>
<li>API for defining new commands in Rust, setting and querying variables, and
evaluating TCL code.</li>
</ul>
</li>
<li>The <code>Value</code> type (e.g., Tcl_Obj)
<ul>
<li>TCL values are strings; <code>Value</code> shares them efficiently by reference counting, and
caches binary data representations for run-time efficiency.</li>
</ul>
</li>
</ul>
<p>Related Tools:</p>
<ul>
<li>An interactive REPL
<ul>
<li>Using the <code>rustyline</code> crate for line editing.</li>
</ul>
</li>
<li>A shell, for execution of script files</li>
<li>A test harness</li>
</ul>
<h2 id="features-to-be-added-soon"><a class="header" href="#features-to-be-added-soon">Features to be added soon</a></h2>
<p>See the <a href="overview.html">overview</a> and the Molt README.</p>
<h2 id="features-to-be-added-eventually"><a class="header" href="#features-to-be-added-eventually">Features to be added eventually</a></h2>
<ul>
<li>Globs and Regexes</li>
<li>Some way to create ensemble commands and simple objects</li>
</ul>
<h2 id="features-that-might-someday-be-added-depending-on-demand"><a class="header" href="#features-that-might-someday-be-added-depending-on-demand">Features that might someday be added (depending on demand)</a></h2>
<ul>
<li>Namespaces</li>
<li>Slave interpreters</li>
<li>File I/O</li>
<li>Event loop</li>
<li>Byte Compilation</li>
<li>Communication between <code>Interps</code> in different threads</li>
<li>Traces</li>
<li>Some kind of TCL-level module architecture</li>
</ul>
<h2 id="features-that-will-almost-certainly-never-be-added"><a class="header" href="#features-that-will-almost-certainly-never-be-added">Features that will almost certainly never be added</a></h2>
<ul>
<li>The TCL autoloader</li>
<li>Packages/TCL Modules (as represented in Standard TCL)</li>
<li>Coroutines</li>
<li>Support for dynamically loading Molt extensions written in Rust</li>
<li>Support for Molt extensions written in C (or anything but Rust)
<ul>
<li>But note that a Molt extension written in Rust can certainly call into
C libraries in the usual way.</li>
</ul>
</li>
<li>Network I/O</li>
<li>OOP (in the form of TclOO)</li>
</ul>
<h2 id="miscellaneous-differences"><a class="header" href="#miscellaneous-differences">Miscellaneous Differences</a></h2>
<p>See the man pages for specific commands for other differences.</p>
<ul>
<li>Integer literals beginning with "0" are NOT assumed to be octal,
Nor will they ever be.</li>
<li>The encoding is currently always UTF-8.</li>
<li>In variable names, e.g. <code>$name</code>, the name may include underscores and any character that
Rust considers to be alphanumeric.</li>
<li>The notion of what constitutes whitespace is generally left up to Rust.</li>
<li>When using the TCL shell interactively, TCL will attempt to match
partial names of commands and subcommands as a convenience.  Molt does not.
<ul>
<li>In principle, some form of tab-completion could be added at some point.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annotated-change-log"><a class="header" href="#annotated-change-log">Annotated Change Log</a></h1>
<h2 id="new-in-molt-032-1"><a class="header" href="#new-in-molt-032-1">New in Molt 0.3.2</a></h2>
<p>Nothing yet!</p>
<h2 id="new-in-molt-031"><a class="header" href="#new-in-molt-031">New in Molt 0.3.1</a></h2>
<ul>
<li>Added the <a href="embed/molt_result.html#result-macros"><strong>molt_throw!</strong></a> macro.</li>
<li>Improved the API documentation for <code>molt_ok!</code> and <code>molt_err!</code>.</li>
<li>Added <code>Exception::error_code</code> and <code>Exception::error_info</code>, to streamline using exceptions.</li>
<li>Added the <code>env()</code> array, which contains the current environment variable settings.
<ul>
<li><strong>Note</strong>: as yet, changes to the <code>env()</code> array are not mirrored back to the process
environment.</li>
</ul>
</li>
<li>Added the <a href="ref/string.html"><strong>string</strong></a> command
<ul>
<li><code>string cat</code></li>
<li><code>string compare</code></li>
<li><code>string first</code></li>
<li><code>string last</code></li>
<li><code>string length</code></li>
<li><code>string map</code></li>
<li><code>string range</code></li>
<li><code>string tolower</code></li>
<li><code>string toupper</code></li>
<li><code>string trim</code></li>
<li><code>string trimleft</code></li>
<li><code>string trimright</code></li>
</ul>
</li>
</ul>
<h2 id="new-in-molt-030"><a class="header" href="#new-in-molt-030">New in Molt 0.3.0</a></h2>
<p>The changes in Molt 0.3.0 break the existing API in two ways:</p>
<ul>
<li>The syntax for <code>molt_shell::repl</code> has changed slightly.</li>
<li>The <code>MoltResult</code> type has changed significantly.</li>
</ul>
<p>Keep reading for the full details.</p>
<h3 id="molt-shell-user-definable-prompts"><a class="header" href="#molt-shell-user-definable-prompts">Molt Shell: User-Definable Prompts</a></h3>
<p>Thanks to Coleman McFarland, <code>molt_shell::repl</code> now supports programmable prompts via the
<code>tcl_prompt1</code> variable.  See the rustdocs and the <a href="cmdline/molt_shell.html"><code>molt_shell</code></a>
discussion in this book for more information.</p>
<h3 id="error-stack-traces"><a class="header" href="#error-stack-traces">Error Stack Traces</a></h3>
<p>Molt now provides error stack traces in more-or-less the same form as standard TCL.  Stack
traces are accessible to Rust clients, are printed by the Molt shell, and can be
accessed in scripts via the <a href="ref/catch.html"><code>catch</code></a> command and the <code>errorInfo</code> variable
in the usual TCL way.</p>
<h3 id="error-codes"><a class="header" href="#error-codes">Error Codes</a></h3>
<p>Molt scripts and Rust code can now throw errors with an explicit error code, as in Standard
TCL; see the <a href="ref/throw.html"><code>throw</code></a> and <a href="ref/catch.html"><code>catch</code></a> commands.</p>
<h3 id="return-protocol"><a class="header" href="#return-protocol">Return Protocol</a></h3>
<p>Molt now supports the full <a href="ref/return.html"><code>return</code></a>/<a href="ref/catch.html"><code>catch</code></a> protocol for
building application-specific control structures in script code.  The mechanism as implemented
is slightly simpler than in Standard TCL, but should be sufficient for all practical
purposes.  See the referenced commands for specifics.</p>
<h3 id="moltresult-and-the-exception-struct"><a class="header" href="#moltresult-and-the-exception-struct"><code>MoltResult</code> and the <code>Exception</code> Struct</a></h3>
<p>In order to support the above changes, the definition of the
<code>MoltResult</code> type has changed.  Instead of</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MoltResult = Result&lt;Value, ResultCode&gt;;
<span class="boring">}</span></code></pre></pre>
<p>it is now</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MoltResult = Result&lt;Value, Exception&gt;;
<span class="boring">}</span></code></pre></pre>
<p>where <code>Exception</code> is a struct containing the <code>ResultCode</code> and other necessary data.  The
<code>ResultCode</code> enum still exists, but has been simplified.  See the rust doc for details.</p>
<h2 id="new-in-molt-02"><a class="header" href="#new-in-molt-02">New in Molt 0.2</a></h2>
<h3 id="dictionaries-and-the-dict-command"><a class="header" href="#dictionaries-and-the-dict-command">Dictionaries and the <code>dict</code> command</a></h3>
<p>Molt now supports TCL dictionary values.  The <a href="ref/dict.html"><code>dict</code></a> command provides the
following subcommands:</p>
<ul>
<li>dict create</li>
<li>dict exists</li>
<li>dict keys</li>
<li>dict get</li>
<li>dict remove</li>
<li>dict set</li>
<li>dict size</li>
<li>dict unset</li>
<li>dict values</li>
</ul>
<p>Other <code>dict</code> subcommands will be added over time.</p>
<h3 id="associative-arrays"><a class="header" href="#associative-arrays">Associative Arrays</a></h3>
<p>Molt now includes TCL's associative array variables:</p>
<pre><code class="language-text">% set a(1) "Howdy"
Howdy
% set a(foo.bar) 5
5
% puts [array get a]
1 Howdy foo.bar 5
</code></pre>
<h3 id="the-expansion-operator"><a class="header" href="#the-expansion-operator">The Expansion Operator</a></h3>
<p>Molt now supports TCL's <code>{*}</code> operator, which expands a single
command argument into multiple arguments:</p>
<pre><code class="language-text">% set a {a b c}
a b c
% list 1 2 $a 3 4
1 2 {a b c} 3 4
% list 1 2 {*}$a 3 4
1 2 a b c 3 4
</code></pre>
<h3 id="more-info-subcommands"><a class="header" href="#more-info-subcommands">More <code>info</code> Subcommands</a></h3>
<p>Molt now supports the following subcommands of the <a href="ref/info.html"><code>info</code></a> command:</p>
<ul>
<li><code>info args</code></li>
<li><code>info body</code></li>
<li><code>info cmdtype</code></li>
<li><code>info default</code></li>
<li><code>info exists</code></li>
<li><code>info globals</code> (no glob-filtering as yet)</li>
<li><code>info locals</code> (no glob-filtering as yet)</li>
<li><code>info procs</code></li>
</ul>
<h3 id="rust-api-change-test-harness"><a class="header" href="#rust-api-change-test-harness">Rust API Change: Test Harness</a></h3>
<p>The Molt test harness code has moved from <code>molt_shell:test_harness</code> to <code>molt::test_harness</code>,
so that it can be used in the <code>molt/tests/tcl_tests.rs</code> integration test.</p>
<h3 id="rust-api-change-variable-access"><a class="header" href="#rust-api-change-variable-access">Rust API Change: Variable Access</a></h3>
<p>The addition of array variables required changes to the <code>molt::Interp</code> struct's API for
setting and retrieving variables.  In particular, the <code>molt::Interp::var</code>,
<code>molt::Interp::set_var</code>, and <code>molt::Interp::set_and_return</code> methods now take the variable
name as a <code>&amp;Value</code> rather than a <code>&amp;str</code>; this simplifies client code, and means that most
commands implemented in Rust that work with variables don't need to care whether the
variable in question is a scalar or an array element.</p>
<h3 id="rust-api-change-command-definition"><a class="header" href="#rust-api-change-command-definition">Rust API Change: Command Definition</a></h3>
<p>Defining Molt commands in Rust has been simplified.</p>
<p>First, the <code>Command</code> trait has been removed.  It was intended to provide a way to
attach context data to a command; but it was not very good for mutable data, and had
no way to share data among related commands (a common pattern).</p>
<p>Second, the interpreter's context cache has been improved.  Multiple commands can share a
context ID (and hence access to the shared context); and the cached data will be dropped
automatically when the last such command is removed from the interpreter.</p>
<p>Third, there is now only one command function signature:</p>
<pre><code>fn my_command(interp: &amp;mut Interp, context_id: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    ...
}
</code></pre>
<p>Commands that don't use a cached context should be defined as follows:</p>
<pre><code>fn my_command(interp: &amp;mut Interp, _: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="molt-command-line-tool"><a class="header" href="#molt-command-line-tool">Molt Command Line Tool</a></h1>
<p>The <code>molt-app</code> crate provides a command line tool for use in development and
experimentation. The command line tool, called <code>molt</code>, has several subcommands:</p>
<p><a href="cmdline/./molt_shell.html"><strong>molt shell</strong></a> executes scripts and provides an
interactive REPL.</p>
<p><a href="cmdline/./molt_test.html"><strong>molt test</strong></a> executes Molt test suites, most notably
Molt's own test suite.</p>
<p><a href="cmdline/./molt_bench.html"><strong>molt bench</strong></a> executes Molt benchmarks.  This tool is
experimental, and is primarily for use in optimizing molt itself.</p>
<p>Note: the <code>molt-shell</code> crate provides the same features for use with customized Molt interpreters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="molt-shell-script-args"><a class="header" href="#molt-shell-script-args">molt shell ?<em>script</em>? ?<em>args...</em>?</a></h1>
<p>The <code>molt shell</code> command invokes the Molt interpreter.</p>
<h2 id="interactive-use"><a class="header" href="#interactive-use">Interactive Use</a></h2>
<p>When called without any arguments, the command invokes the interactive interpreter:</p>
<pre><code class="language-tcl">$ molt shell
Molt 0.3.0
%
</code></pre>
<p>Molt commands may be entered at the <code>%</code> prompt.  Enter <code>exit</code> to leave the interpreter.</p>
<h2 id="script-execution"><a class="header" href="#script-execution">Script Execution</a></h2>
<p>When called with arguments, the first argument is presumed to be the name of a Molt script;
any subsequent arguments are passed to the script.</p>
<pre><code class="language-tcl">$ molt shell my_script.tcl arg1 arg2 arg3
...
$
</code></pre>
<p>When called in this way, the variable <strong>arg0</strong> contains the name of the script, and the
variable <strong>argv</strong> contains a list of the additional arguments (if any).</p>
<p>For example, consider the following script, <code>args.tcl</code>:</p>
<pre><code class="language-tcl">puts "arg0 = $arg0"
puts "argv = $argv"
</code></pre>
<p>This script may be run as follows</p>
<pre><code class="language-tcl">$ molt shell args.tcl a b c
arg0 = args.tcl
argv = a b c
$
</code></pre>
<h2 id="interactive-prompts"><a class="header" href="#interactive-prompts">Interactive Prompts</a></h2>
<p>The <code>molt shell</code> and its underlying method, <code>molt_shell::repl</code>, support interactive prompts
via the <code>tcl_prompt1</code> variable.  If defined, <code>tcl_prompt1</code> should be a script; its value
will be output as the prompt.</p>
<pre><code class="language-tcl">$ molt shell
% set count 0
% set tcl_prompt1 {return "[incr count]&gt; "}
return "[incr count]&gt; "
1&gt; puts "Howdy!"
Howdy!
2&gt;
</code></pre>
<p>This is slightly different than in Standard TCL, where the <code>tcl_prompt1</code> script is intended
to output the prompt rather than return it.</p>
<h2 id="tcl-liens"><a class="header" href="#tcl-liens">TCL Liens</a></h2>
<p>The Standard TCL shell, <code>tclsh</code>, provides a number of features that Molt currently does not.</p>
<ul>
<li>
<p>A <code>.tclshrc</code> file for initializing interactive shells.</p>
<ul>
<li>A similar file will be added in the future.</li>
</ul>
</li>
<li>
<p>An option to execute a script and then start the interactive shell.</p>
<ul>
<li>This can be added if there is demand.</li>
</ul>
</li>
<li>
<p>Environment variables for locating the interpreter's library of TCL code, locally
installed TCL packages, etc.</p>
<ul>
<li>Molt's library of TCL code is compiled into the interpreter, rather than being
loaded from disk at run-time.</li>
<li>At present, Molt has no support for externally-defined TCL packages
(other than the <code>source</code> command).</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="molt-test-filename-args"><a class="header" href="#molt-test-filename-args">molt test <em>filename</em> ?<em>args...</em>?</a></h1>
<p>This command executes the test script called <em>filename</em> using the Molt
test harness, which is similar to Standard TCL's <code>tcltest</code> framework (though
much simpler, at present). Any arguments are passed to the test harness
(which ignores them, at present).</p>
<h2 id="test-suites"><a class="header" href="#test-suites">Test Suites</a></h2>
<p><code>molt test</code> is often used to execute an entire test suite, spread over
multiple files.  To simplify writing such a suite, <code>molt test</code> assumes
that the folder containing the specified <em>filename</em> is the base folder for
the test suite, and sets the current working directory to that folder.
This allows the named test script to use <a href="cmdline/../ref/source.html"><strong>source</strong></a> to
load other test scripts using paths relative to its own location.</p>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<p>Tests are written using the <a href="cmdline/../ref/test.html"><strong>test</strong></a> command.  See
that man page for examples.</p>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<p>For example,</p>
<pre><code class="language-tcl">$ molt test good_tests.tcl
molt 0.2.0 -- Test Harness

5 tests, 5 passed, 0 failed, 0 errors
$ molt test bad_tests.tcl
molt 0.2.0 -- Test Harness

*** FAILED mytest-1.1 some proc
Expected -ok &lt;this result&gt;
Received -ok &lt;that result&gt;

2 tests, 1 passed, 1 failed, 0 errors
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-name-description-args-"><a class="header" href="#test-name-description-args-">test <em>name</em> <em>description</em> <em>args ...</em></a></h1>
<p><strong>Available in <a href="cmdline/test_commands/../molt_test.html"><strong>molt test</strong></a> scripts only!</strong></p>
<p>The <code>test</code> command executes its body as a Molt script and compares its result
to an expected value.  It may be used to test Molt commands, whether built-in or coded
in Molt.  The expected value may be an <code>-ok</code> result or an <code>-error</code> message.</p>
<p>The <em>name</em> and <em>description</em> are used to identify the test in the output.  The
<em>name</em> can be any string, but the convention is to use the format
"<em>baseName</em>-<em>x</em>.<em>y</em>", e.g., <code>mycommand-1.1</code>.  In the future, <code>molt test</code>
will allow the user to filter the set of tests on this name string.</p>
<p>The test is executed in its own local variable scope; variables used by the
test will be cleaned up automatically at the end of the test.  The
<a href="cmdline/test_commands/../../ref/global.html"><strong>global</strong></a> command may be used to reference global variables; however,
changes to these must be cleaned up explicitly.  Similarly, any
<a href="cmdline/test_commands/../../ref/proc.html"><strong>procs</strong></a> defined by the test must be cleaned up explicitly.</p>
<p>The <code>test</code> command has two forms, a brief form and an extended form with more options.</p>
<h2 id="test-name-description-body--ok-error-expectedvalue"><a class="header" href="#test-name-description-body--ok-error-expectedvalue">test <em>name</em> <em>description</em> <em>body</em> -ok|-error <em>expectedValue</em></a></h2>
<p>In the brief form, the <em>body</em> is the test script itself; and it is expected to return
a normal result or an error message.  Either way, <em>expectedValue</em> is the expected value.</p>
<ul>
<li>The test <strong>passes</strong> if the <em>body</em> returns the right kind of result with the expected value.</li>
<li>The test <strong>fails</strong> if the <em>body</em> returns the right kind of result (e.g., <code>-ok</code>) with
some other value.</li>
<li>The test is in <strong>error</strong> if the <em>body</em> returns the wrong kind of result, (e.g., an
error was returned when a normal result was expected).</li>
</ul>
<h2 id="test-name-description-option-value-option-value-"><a class="header" href="#test-name-description-option-value-option-value-">test <em>name</em> <em>description</em> <em>option value</em> ?<em>option value ...</em>?</a></h2>
<p>In the extended form, the details of the test are specified using options:</p>
<ul>
<li>
<p><strong>-setup</strong>: indicates a setup script, which will be executed before the body of the
test.  The test is flagged as an <strong>error</strong> if the setup script returns anything
but a normal result.</p>
</li>
<li>
<p><strong>-body</strong>: indicates the test's <em>body</em>, which is interpreted as described above.</p>
</li>
<li>
<p><strong>-cleanup</strong>: indicates a cleanup script, which will be executed after the body of the
test.  The test is flagged as an <strong>error</strong> if the cleanup script returns anything but
a normal result.</p>
</li>
<li>
<p><strong>-ok | -error</strong>: indicates the expected value, as described above.</p>
</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>The following tests are for an imaginary <code>square</code> command that returns the square
of a number.  They use the brief form.</p>
<pre><code class="language-Tcl">test square-1.1 {square errors} {
    square
} -error {wrong # args: should be "square number"}

test square-2.1 {square command} {
    square 3
} -ok {9}
</code></pre>
<p>The following test shows the extended form:</p>
<pre><code class="language-Tcl">test newproc-1.1 {new proc} -setup {
    # Define a proc for use in the test
    proc myproc {} { return "called myproc" }
} -body {
    # Call the proc
    myproc
} -cleanup {
    # Clean up the proc
    rename myproc ""
} -error {called myproc}
</code></pre>
<h2 id="tcl-notes"><a class="header" href="#tcl-notes">TCL Notes</a></h2>
<p>This command is a simplified version of the <code>test</code> command defined by
Standard TCL's <code>tcltest(n)</code> framework.  The intention is to increase the
similarity over time.</p>
<p>This command has an enhancement over TCL's <code>test</code> command: the test has
its own local variable scope, just as a <a href="cmdline/test_commands/../../ref/proc.html"><strong>proc</strong></a> does.  The body
must use the <a href="cmdline/test_commands/../../ref/global.html"><strong>global</strong></a> command to access global variables.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="molt-bench-filename--csv"><a class="header" href="#molt-bench-filename--csv">molt bench <em>filename</em> ?-csv?</a></h1>
<p>This command executes the benchmark script called <em>filename</em> using the Molt benchmark
framework. The framework runs the benchmarks in the script and outputs the results in
nanoseconds.</p>
<p><strong>NOTE:</strong> The benchmark tool is experimental, subject to change, and primarily intended
as aid for Molt optimization.</p>
<p>The output looks like this.</p>
<pre><code class="language-console">$ molt bench benchmarks/basic.tcl
Molt 0.2.0 -- Benchmark

   Nanos     Norm -- Benchmark
    3344     1.00 -- ok-1.1 ok, no arguments
    4110     1.23 -- ok-1.2 ok, one argument
    4442     1.33 -- ok-1.3 ok, two arguments
    4005     1.20 -- ident-1.1 ident, simple argument
    7175     2.15 -- incr-1.1 incr a
    6648     1.99 -- set-1.1 set var value
    7926     2.37 -- list-1.1 list of six items
...
$
</code></pre>
<p>The <code>Norm</code> column shows the times relative to the first benchmark in the set.</p>
<h2 id="csv-output"><a class="header" href="#csv-output">CSV Output</a></h2>
<p>Use the <code>-csv</code> option to produce output in CSV format:</p>
<pre><code class="language-console">$ molt bench benchmarks/basic.tcl -csv
"benchmark","description","nanos","norm"
"ok-1.1","ok, no arguments",3313,1
"ok-1.2","ok, one argument",4027,1.2155146392997283
"ok-1.3","ok, two arguments",4439,1.3398732266827649
"ident-1.1","ident, simple argument",4026,1.2152127980682161
"incr-1.1","incr a",7325,2.210987020827045
"set-1.1","set var value",6499,1.9616661635979475
"list-1.1","list of six items",7848,2.3688499849079383
...
</code></pre>
<h2 id="writing-benchmarks"><a class="header" href="#writing-benchmarks">Writing Benchmarks</a></h2>
<p>Benchmarks are written using the <a href="cmdline/./bench_commands/benchmark.html"><strong>benchmark</strong></a> or
<a href="cmdline/./bench_commands/measure.html"><strong>measure</strong></a> commands.  See those man pages for examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark-name-description-body-count"><a class="header" href="#benchmark-name-description-body-count">benchmark <em>name</em> <em>description</em> <em>body</em> ?<em>count</em>?</a></h1>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>Defines a benchmark with the given name and description.  The <em>body</em> is a Tcl script; it is executed <em>count</em> times via the <a href="cmdline/bench_commands/../../ref/time.html"><strong>time</strong></a> command, and records the average runtime in microseconds.  The count defaults to 1000 iterations.</p>
<p>The <em>name</em> should be a symbolic name for easy searching; the <em>description</em> should be a
brief human-readable description of the benchmark.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>The following is a simple benchmark of the <a href="cmdline/bench_commands/../../ref/incr.html"><strong>incr</strong></a> command.</p>
<pre><code class="language-tcl">benchmark incr-1.1 {incr a} {
    incr a
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="measure-name-description-micros"><a class="header" href="#measure-name-description-micros">measure <em>name</em> <em>description</em> <em>micros</em></a></h1>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>This is a low-level command used by the <a href="cmdline/bench_commands/./benchmark.html"><strong>benchmark</strong></a> command
to record measurements.  All recorded measurements will be included in the tool's
output.</p>
<p>Benchmark scripts won't usually need to call this; however, it can
be useful when defining custom benchmarking commands.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-tcl">measure incr-1.1 "incr a" 1.46
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ok-arg-arg"><a class="header" href="#ok-arg-arg">ok ?<em>arg</em> <em>arg</em>...?</a></h1>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>This command takes any number of arguments and returns the empty string.  It is useful when benchmarking code that calls other commands, as (with no arguments) it represents the minimum
amount of computation the Molt interpreter can do.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>For example, Molt's own benchmark suite includes the following as its baseline, as a lower bound on the run-time of evaluating a script:</p>
<pre><code class="language-tcl">benchmark ok-1.1 {ok, no arguments} {
    ok
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ident-value"><a class="header" href="#ident-value">ident <em>value</em></a></h1>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>Returns its argument unchanged.  Like <a href="cmdline/bench_commands/./ok.html"><strong>ok</strong></a>, this is a command used for
constructing benchmarks of the Molt interpreter itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="molt-command-reference"><a class="header" href="#molt-command-reference">Molt Command Reference</a></h1>
<p>Molt implements the following commands.  See the reference for each
command to see any differences from Standard TCL.</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="ref/append.html"><strong>append</strong></a></td><td>Appends values to a list</td></tr>
<tr><td><a href="ref/array.html"><strong>array</strong></a></td><td>Query and manipulate array variables</td></tr>
<tr><td><a href="ref/assert_eq.html"><strong>assert_eq</strong></a></td><td>Equality assertion</td></tr>
<tr><td><a href="ref/break.html"><strong>break</strong></a></td><td>Break loop execution</td></tr>
<tr><td><a href="ref/catch.html"><strong>catch</strong></a></td><td>Catch exceptions</td></tr>
<tr><td><a href="ref/continue.html"><strong>continue</strong></a></td><td>Continue with next iteration</td></tr>
<tr><td><a href="ref/dict.html"><strong>dict</strong></a></td><td>Dictionary manipulation</td></tr>
<tr><td><a href="ref/error.html"><strong>error</strong></a></td><td>Throws an error</td></tr>
<tr><td><a href="ref/exit.html"><strong>exit</strong></a></td><td>Exit the application</td></tr>
<tr><td><a href="ref/expr.html"><strong>expr</strong></a></td><td>Evaluate algebraic expressions</td></tr>
<tr><td><a href="ref/for.html"><strong>for</strong></a></td><td>"For" loop</td></tr>
<tr><td><a href="ref/foreach.html"><strong>foreach</strong></a></td><td>"For each" loop</td></tr>
<tr><td><a href="ref/global.html"><strong>global</strong></a></td><td>Bring global into scope</td></tr>
<tr><td><a href="ref/if.html"><strong>if</strong></a></td><td>If/then/else</td></tr>
<tr><td><a href="ref/incr.html"><strong>incr</strong></a></td><td>Increment integer</td></tr>
<tr><td><a href="ref/info.html"><strong>info</strong></a></td><td>Interpreter introspection</td></tr>
<tr><td><a href="ref/join.html"><strong>join</strong></a></td><td>Join list elements into a string</td></tr>
<tr><td><a href="ref/lindex.html"><strong>lindex</strong></a></td><td>Index into a list</td></tr>
<tr><td><a href="ref/list.html"><strong>list</strong></a></td><td>Create a list</td></tr>
<tr><td><a href="ref/llength.html"><strong>llength</strong></a></td><td>Length of a list</td></tr>
<tr><td><a href="ref/proc.html"><strong>proc</strong></a></td><td>Procedure definition</td></tr>
<tr><td><a href="ref/puts.html"><strong>puts</strong></a></td><td>Print a string</td></tr>
<tr><td><a href="ref/rename.html"><strong>rename</strong></a></td><td>Rename a command</td></tr>
<tr><td><a href="ref/return.html"><strong>return</strong></a></td><td>Return a value</td></tr>
<tr><td><a href="ref/set.html"><strong>set</strong></a></td><td>Set a variable's value</td></tr>
<tr><td><a href="ref/source.html"><strong>source</strong></a></td><td>Evaluate a script file</td></tr>
<tr><td><a href="ref/string.html"><strong>string</strong></a></td><td>String manipulation</td></tr>
<tr><td><a href="ref/throw.html"><strong>throw</strong></a></td><td>Throws an exception</td></tr>
<tr><td><a href="ref/time.html"><strong>time</strong></a></td><td>Time script execution</td></tr>
<tr><td><a href="ref/unset.html"><strong>unset</strong></a></td><td>Clear a variable</td></tr>
<tr><td><a href="ref/while.html"><strong>while</strong></a></td><td>"While" loop</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="append----appends-values-to-a-list"><a class="header" href="#append----appends-values-to-a-list">append -- Appends values to a list</a></h1>
<p><strong>Syntax: append <em>varName</em> ?<em>value</em> ...?</strong></p>
<p>Appends zero or more values to the value of variable <em>varName</em>.
If <em>varName</em> didn't previously exist, it is set to the concatenation
of the values.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<pre><code class="language-Tcl">set x "this"
append x "that"
assert_eq $x "thisthat"

append y a b c
assert_eq $y abc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array----query-and-manipulate-array-variables"><a class="header" href="#array----query-and-manipulate-array-variables">array -- Query and manipulate array variables</a></h1>
<p><strong>Syntax: array <em>subcommand</em> ?<em>arg</em> ...?</strong></p>
<p>This command queries and manipulates array variables.</p>
<div class="table-wrapper"><table><thead><tr><th>Subcommand</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="ref/array.html#array-exists">array exists</a></td><td>Is the string the name of an array variable?</td></tr>
<tr><td><a href="ref/array.html#array-get">array get</a></td><td>A dictionary of the array's elements by name</td></tr>
<tr><td><a href="ref/array.html#array-names">array names</a></td><td>A list of the array's indices</td></tr>
<tr><td><a href="ref/array.html#array-set">array set</a></td><td>Merges a dictionary of elements into the array</td></tr>
<tr><td><a href="ref/array.html#array-size">array size</a></td><td>The number of elements in the array</td></tr>
<tr><td><a href="ref/array.html#array-unset">array unset</a></td><td>Unsets an array variable</td></tr>
</tbody></table>
</div>
<p><strong>TCL Liens</strong></p>
<ul>
<li>Does not support filtering using glob or regex matches at this time.  The plan is to
support glob and regex matching as a configuration option at build time.</li>
<li>Will never support the array iteration commands <code>array startsearch</code>, <code>array anymore</code>,
<code>array donesearch</code>, <code>array nextelement</code>, because they are unnecessary and rarely used.
The normal idiom for iterating over an array is a <code>foreach</code> over <code>array names</code>.</li>
<li>Will never support <code>array statistics</code>, as Rust's <code>std::collections::HashMap</code> doesn't
provide a way to gather them.</li>
</ul>
<h2 id="array-exists"><a class="header" href="#array-exists">array exists</a></h2>
<p><strong>Syntax: array exists <em>arrayName</em></strong></p>
<p>Returns 1 if <em>arrayName</em> names an array variable, and 0 otherwise.</p>
<h2 id="array-get"><a class="header" href="#array-get">array get</a></h2>
<p><strong>Syntax: array get <em>arrayName</em></strong></p>
<p>Returns a flat list of the keys and values in the named array.  The key/value pairs appear
in unsorted order. If there is no array variable with the given name, returns the empty list.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using glob and regex matches.</p>
<h2 id="array-names"><a class="header" href="#array-names">array names</a></h2>
<p><strong>Syntax: array names <em>arrayName</em></strong></p>
<p>Returns an unsorted list of the indices of the named array variable.  If there is no array
variable with the given name, returns the empty list.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using glob and regex matches.</p>
<h2 id="array-set"><a class="header" href="#array-set">array set</a></h2>
<p><strong>Syntax: array set <em>arrayName</em> <em>list</em></strong></p>
<p>Merges a flat list of keys and values into the array, creating the array variable if necessary.
The list must have an even number of elements.  It's an error if the variable exists but has
a scalar value, or if <em>arrayName</em> names an array element.</p>
<h2 id="array-size"><a class="header" href="#array-size">array size</a></h2>
<p><strong>Syntax: array size <em>arrayName</em></strong></p>
<p>Returns the number of elements in the named array.  If there is no array
variable with the given name, returns "0".</p>
<h2 id="array-unset"><a class="header" href="#array-unset">array unset</a></h2>
<p><strong>Syntax: array unset <em>arrayName</em> ?<em>index</em>?</strong></p>
<p>Unsets the array element in <em>arrayName</em> with the given <em>index</em>.  If index is not given,
unsets the entire array.</p>
<p>Note:</p>
<ul>
<li><code>array unset my_array</code> is equivalent to <code>unset my_array</code>, but only works on array variables.</li>
<li><code>array unset my_array my_index</code> is equivalent to <code>unset my_array(my_index)</code></li>
</ul>
<p>The real value of <code>array unset</code> depends on pattern matching on the index argument, which is
not yet available.</p>
<p><strong>TCL Liens</strong>: does not support glob matching on the optional argument.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert_eq----equality-assertion"><a class="header" href="#assert_eq----equality-assertion">assert_eq -- Equality assertion</a></h1>
<p><strong>Syntax: assert_eq <em>received</em> <em>expected</em></strong></p>
<p>Asserts that the string <em>received</em> equals the string <em>expected</em>.  On success,
returns the empty string; on failure, returns an error.</p>
<p>This command is primarily intended for use in examples, to show the expected
result of a computation, rather than for use in test suites.  For testing,
see the <a href="ref/./test.html"><code>test</code></a> command and the
<a href="ref/../cmdline/molt_test.html"><code>molt test</code></a> tool.</p>
<h2 id="tcl-notes-1"><a class="header" href="#tcl-notes-1">TCL Notes</a></h2>
<p>This command is not part of Standard TCL; it is provided because of its
similarity to the Rust <code>assert_eq!</code> macro.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="break----break-loop-execution"><a class="header" href="#break----break-loop-execution">break -- Break loop execution</a></h1>
<p><strong>Syntax: break</strong></p>
<p>Breaks execution of the inmost loop containing the <code>break</code> command,
continuing execution after the loop.</p>
<pre><code class="language-Tcl">foreach item $list {
    ...
    if {[someCondition]} {
        break
    }
    ...
}

# Execution continues here after the break
</code></pre>
<h2 id="break-and-return"><a class="header" href="#break-and-return"><code>break</code> and <code>return</code></a></h2>
<p>The <code>break</code> command is semantically equivalent to <code>return -code break -level 0</code>, as is
the following procedure:</p>
<pre><code class="language-tcl">proc my_break {} {
    return -code break -level 1
}
</code></pre>
<p>See the <a href="ref/return.html"><strong>return</strong></a> reference page for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catch----catch-exceptions"><a class="header" href="#catch----catch-exceptions">catch -- Catch exceptions</a></h1>
<p><strong>Syntax: catch <em>script</em> ?<em>resultVarName</em>? ?<em>optionsVarName</em>?</strong></p>
<p>Executes the script, catching the script's result.  The <code>catch</code> command returns an integer
result code, indicating why the script returned.  If <em>resultVarName</em> is given, the
named variable in the caller's scope is set to the script's actual return value.  If
<em>optionsVarName</em> is given, the named variable is set to the <a href="ref/./return.html"><strong>return</strong></a> options
dictionary in the caller's scope.</p>
<p><code>catch</code> is most often used to catch errors.  For example,</p>
<pre><code class="language-tcl">if {[catch {do_something} result]} {
    puts "Error message: $result"
} else {
    puts "Good result: $result"
}
</code></pre>
<h2 id="return-codes"><a class="header" href="#return-codes">Return Codes</a></h2>
<p>The return value of <code>catch</code> is an integer code that indicates why the script returned.  There are
five standard return codes:</p>
<div class="table-wrapper"><table><thead><tr><th>Return Code</th><th>Effect</th></tr></thead><tbody>
<tr><td>0 (ok)</td><td>Normal. The result variable is set to the script's result.</td></tr>
<tr><td>1 (error)</td><td>A command in the script threw an error. The result variable is set to the error message.</td></tr>
<tr><td>2 (return)</td><td>The script called <a href="ref/./return.html"><strong>return</strong></a>. The result variable is set to the returned value.</td></tr>
<tr><td>3 (break)</td><td>The script called <a href="ref/./break.html"><strong>break</strong></a>.</td></tr>
<tr><td>4 (continue)</td><td>The script called <a href="ref/./continue.html"><strong>continue</strong></a>.</td></tr>
</tbody></table>
</div>
<p>In addition, the <code>return</code> command allows any integer to be used as a return code; together with
<code>catch</code>, this can be used to implement new control structures.</p>
<h2 id="the-errorcode-and-errorinfo-variables"><a class="header" href="#the-errorcode-and-errorinfo-variables">The <code>errorCode</code> and <code>errorInfo</code> Variables</a></h2>
<p>When <code>catch</code> catches an error (or when an error message is output in the Molt REPL), the
global variable <code>errorCode</code> will be set to the specific error code (see <a href="ref/throw.html"><strong>throw</strong></a>)
and the global variable <code>errorInfo</code> will be set to a human-readable stack trace.</p>
<h2 id="the-options-dictionary"><a class="header" href="#the-options-dictionary">The Options Dictionary</a></h2>
<p>The options dictionary saved to the <em>optionsVarName</em> contains complete information about the
return options.  See <a href="ref/return.html"><strong>return</strong></a> for a complete discussion of what the return
options are and how they are used.</p>
<h2 id="rethrowing-an-error"><a class="header" href="#rethrowing-an-error">Rethrowing an Error</a></h2>
<p>Sometimes it's desirable to catch an error, take some action (e.g., log it), and then rethrow
it.  The <code>return</code> command is used to do this:</p>
<pre><code>set code [catch {
    # Some command or script that can throw an error
} result opts]

if {$code == 1} {
    # Log the error message
    puts "Got an error: $result"

    # Rethrow the error by returning with exactly the options and return
    # result that we received.
    return {*}$opts $result
}
</code></pre>
<h2 id="visualizing-the-return-protocol"><a class="header" href="#visualizing-the-return-protocol">Visualizing the Return Protocol</a></h2>
<p>The semantics of the <code>return</code>/<code>catch</code> protocol are tricky.  When implementing a new control
structure, or a modified or extended version of <code>return</code>, <code>break</code>, <code>continue</code>, etc., it is
often useful to execute short scripts and examine the options dictionary in the REPL:</p>
<pre><code class="language-tcl">% catch { break } result opts
3
% set result
% set opts
-code 3 -level 0
% catch { return "Foo" } result opts
2
% set result
Foo
% set opts
-code 0 -level 1
%
</code></pre>
<p>This REPL dialog shows that <code>break</code> yields result code 3 immediately, to be handled by the
calling command (usually a loop), while <code>return</code> returns from the calling procedure (<code>-level 1</code>)
and then yields an <code>ok</code> (i.e., normal) result to <em>its</em> caller.</p>
<h2 id="tcl-liens-1"><a class="header" href="#tcl-liens-1">TCL Liens</a></h2>
<p>Molt's <code>catch</code> command differs from Standard TCL's in the following ways:</p>
<ul>
<li>
<p>The options dictionary, as returned, lacks the <code>-errorline</code> and <code>-errorstack</code> options.  These
might be added over time.</p>
</li>
<li>
<p>All options passed to <code>return</code>, whether understood by Standard TCL or not, are passed through
and included in the <code>catch</code> options dictionary.  Molt does not currently support this.</p>
</li>
</ul>
<p>All of the common patterns of use are supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continue----continue-with-next-iteration"><a class="header" href="#continue----continue-with-next-iteration">continue -- Continue with next iteration</a></h1>
<p><strong>Syntax: continue</strong></p>
<p>Continues execution with the next iteration of the inmost loop containing
the <code>continue</code> command.</p>
<pre><code class="language-Tcl">foreach item $list {
    ...
    if {[someCondition]} {
        continue
    }

    # Skips this code on [someCondition]
    ...
}
</code></pre>
<h2 id="continue-and-return"><a class="header" href="#continue-and-return"><code>continue</code> and <code>return</code></a></h2>
<p>The <code>continue</code> command is semantically equivalent to <code>return -code continue -level 0</code>, as is
the following procedure:</p>
<pre><code class="language-tcl">proc my_continue {} {
    return -code continue -level 1
}
</code></pre>
<p>See the <a href="ref/return.html"><strong>return</strong></a> reference page for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dict----dictionary-manipulation"><a class="header" href="#dict----dictionary-manipulation">dict -- Dictionary manipulation</a></h1>
<p><strong>Syntax: dict <em>subcommand</em> ?<em>arg</em> ...?</strong></p>
<p>This command manipulates TCL dictionaries.  A dictionary is a Molt value containing a hash map
from keys to values.  Keys are maintained in order of initial insertion.</p>
<div class="table-wrapper"><table><thead><tr><th>Subcommand</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="ref/dict.html#dict-create">dict create</a></td><td>Creates a dictionary</td></tr>
<tr><td><a href="ref/dict.html#dict-exists">dict exists</a></td><td>Is there a value with these keys?</td></tr>
<tr><td><a href="ref/dict.html#dict-get">dict get</a></td><td>Gets a value from the dictionary</td></tr>
<tr><td><a href="ref/dict.html#dict-keys">dict keys</a></td><td>Gets the keys from the dictionary</td></tr>
<tr><td><a href="ref/dict.html#dict-remove">dict remove</a></td><td>Removes keys from the dictionary</td></tr>
<tr><td><a href="ref/dict.html#dict-set">dict set</a></td><td>Sets a value in a dictionary</td></tr>
<tr><td><a href="ref/dict.html#dict-unset">dict unset</a></td><td>Unsets a value in a dictionary</td></tr>
<tr><td><a href="ref/dict.html#dict-size">dict size</a></td><td>The number of elements in the dictionary</td></tr>
<tr><td><a href="ref/dict.html#dict-values">dict values</a></td><td>Gets the values from the dictionary</td></tr>
</tbody></table>
</div>
<p><strong>TCL Liens</strong></p>
<ul>
<li>Not all of the standard TCL <code>dict</code> subcommands are implemented at this time.</li>
<li><code>dict keys</code> and <code>dict values</code> do not support filtering using glob or regex matches
at this time.  The plan is to support glob and regex matching as an optional feature.</li>
<li><code>dict info</code> is not supported; it is intended for tuning the standard TCL hash table
implementation.  Molt relies on <code>std::collections::HashMap</code>.</li>
</ul>
<h2 id="dict-create"><a class="header" href="#dict-create">dict create</a></h2>
<p><strong>Syntax: dict create ?<em>key</em> <em>value</em> ...?</strong></p>
<p>Creates a dictionary given any number of key/value pairs.</p>
<pre><code class="language-tcl">% set dict [dict create a 1 b 2]
a 1 b 2
% dict get $dict a
1
</code></pre>
<h2 id="dict-exists"><a class="header" href="#dict-exists">dict exists</a></h2>
<p><strong>Syntax: dict exists <em>dictionary</em> <em>key</em> ?<em>key</em> ...?</strong></p>
<p>Returns 1 if the <em>key</em> (or the path of keys through nested dictionaries) is found in the
given <em>dictionary</em> value, and 0 otherwise.  It returns 1 exactly when <code>dict get</code> will
succeed for the same arguments.  It does not throw errors on invalid dictionary values, but
simply returns 0.</p>
<p>Looks up the <em>key</em> in the <em>dictionary</em> and returns its value.  It's an error if the <em>key</em> is
not present in the dictionary.  If multiple keys are provided, the command looks up values
through nested dictionaries.  If no keys are provided, the dictionary itself is returned.</p>
<pre><code class="language-tcl">% dict exists {a 1 b 2} b
1
% dict exists {a {x 1 y2} b {p 3 q 4}} b p
1
% dict exists {a 1 b 2} c
0
% dict exists not-a-dict a
0
</code></pre>
<h2 id="dict-get"><a class="header" href="#dict-get">dict get</a></h2>
<p><strong>Syntax: dict get <em>dictionary</em> ?<em>key</em> ...?</strong></p>
<p>Looks up the <em>key</em> in the <em>dictionary</em> and returns its value.  It's an error if the <em>key</em> is
not present in the dictionary.  If multiple keys are provided, the command looks up values
through nested dictionaries.  If no keys are provided, the dictionary itself is returned.</p>
<pre><code class="language-tcl">% dict get {a 1 b 2} b
2
% dict get {a {x 1 y2} b {p 3 q 4}} b p
3
</code></pre>
<h2 id="dict-keys"><a class="header" href="#dict-keys">dict keys</a></h2>
<p><strong>Syntax: dict keys <em>dictionary</em></strong></p>
<p>Returns a list of the keys in the dictionary, in the order of initial insertion.</p>
<pre><code class="language-tcl">% dict keys {a 1 b 2}
a b
</code></pre>
<h2 id="dict-remove"><a class="header" href="#dict-remove">dict remove</a></h2>
<p><strong>Syntax: dict remove <em>dictionary</em> ?<em>key</em> ...?</strong></p>
<p>Removes each of the keys from the dictionary, returning the modified dictionary.  The keys
need not be present in the original dictionary value.  If no keys are given, returns the
dictionary unchanged.</p>
<pre><code class="language-tcl">% dict remove {a 1 b 2 c 3 d 4} b c
a 1 d 4
</code></pre>
<h2 id="dict-set"><a class="header" href="#dict-set">dict set</a></h2>
<p><strong>Syntax: dict set <em>dictVarName</em> <em>key</em> ?<em>key</em> ...? <em>value</em></strong></p>
<p>Given the name of a variable containing a dictionary, sets the <em>value</em> of the given <em>key</em> in
the dictionary. If multiple keys are given, the command indexes down the path of keys and sets
the value in the nested dictionary.  The variable is created if it does not exist, and the nested
dictionaries are also created as needed.  Returns the modified dictionary, which is also saved
back into the variable.</p>
<p>For example,</p>
<pre><code class="language-tcl">% dict set var a 1
a 1
% dict set var b 2
a 1 b 2
% dict set var c x 3
a 1 b 2 c {x 3}
% dict set var c y z 4
a 1 b 2 c {x 3 y {z 4}}
</code></pre>
<h2 id="dict-size"><a class="header" href="#dict-size">dict size</a></h2>
<p><strong>Syntax: dict size <em>dictionary</em></strong></p>
<p>Gets the number of entries in the <em>dictionary</em>.</p>
<pre><code>% set dict [dict create a 1 b 2 c 3]
a 1 b 2 c 3
% dict size $dict
3
</code></pre>
<h2 id="dict-unset"><a class="header" href="#dict-unset">dict unset</a></h2>
<p><strong>Syntax: dict unset <em>dictVarName</em> ?<em>key</em> ...?</strong></p>
<p>Given the name of a variable containing a dictionary, removes the <em>value</em> at the end of the path
of keys through any number of nested dictionaries.  The last key need not exist in the inmost
dictionary, but it is an error if any of the other dictionaries in the path are unknown.
Returns the modified dictionary, which is also saved back into the variable.</p>
<p>For example,</p>
<pre><code class="language-tcl">% set var {a 1 b {x 2 z 3} c 4}
a 1 b {x 2 y 3} c 4
% dict unset c        ;# Remove "c" from the outermost dictionary
a 1 b {x 2 y 3}
% dict unset b y      ;# Remove "y" from an inner dictionary "b"
a 1 b {x 2}
% dict unset var c    ;# "c" is already not there
a 1 b {x 2}
% dict unset var b y  ;# "y" is already not in "b"
a 1 b {x 2}
% dict unset var c z  ;# Inner dictionary "c" is not present.
key "c" is not known in dictionary
</code></pre>
<h2 id="dict-values"><a class="header" href="#dict-values">dict values</a></h2>
<p><strong>Syntax: dict values <em>dictionary</em></strong></p>
<p>Returns a list of the values in the dictionary, in the order of initial insertion of
their keys.</p>
<pre><code class="language-tcl">% dict values {a 1 b 2}
1 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error----throws-an-error"><a class="header" href="#error----throws-an-error">error -- Throws an error</a></h1>
<p><strong>Syntax: error <em>message</em></strong></p>
<p>Returns an error with the given <em>message</em> and an error code of <code>NONE</code>.  The error may
be caught using the <a href="ref/./catch.html"><strong>catch</strong></a> command.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><code class="language-tcl">proc myproc {x} {
    if {$x &lt; 0} {
        error "input must be non-negative"
    }
    ...
}
</code></pre>
<h2 id="tcl-liens-2"><a class="header" href="#tcl-liens-2">TCL Liens</a></h2>
<p>In standard TCL, the <code>error</code> also has optional <code>errorInfo</code> and <code>errorCode</code> arguments.  These
are used in older TCL code to rethrow errors without polluting the stack trace.  Modern TCL code
uses the <a href="ref/./throw.html"><strong>throw</strong></a> command to throw an error with an error code and the
<a href="ref/./return.html"><strong>return</strong></a> command to rethrow an error (see the reference page for an
example).  Consequently, Molt doesn't implement these arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exit----exit-the-application"><a class="header" href="#exit----exit-the-application">exit -- Exit the application</a></h1>
<p><strong>Syntax: exit ?<em>returnCode</em>?</strong></p>
<p>Terminates the application by calling
<a href="https://doc.rust-lang.org/std/process/fn.exit.html"><code>std::process:exit()</code></a>
with the given <em>returnCode</em>, which must be an integer.  If not present,
the <em>returnCode</em> defaults to 0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expr----evaluate-algebraic-expressions"><a class="header" href="#expr----evaluate-algebraic-expressions">expr -- Evaluate algebraic expressions</a></h1>
<p><strong>Syntax: expr <em>expr</em></strong></p>
<p>Evaluates the expression, returning the result.</p>
<p><code>expr</code> implements a little language that has a syntax separate from that of Molt. An
expression is composed of values and operators, with parentheses for grouping, just
as in C, Java, and so forth.  Values consist of numeric and boolean literals,
<a href="ref/expr.html#math-functions">function calls</a>, variable and command interpolations, and double-quoted
and braced strings. Every value that looks like a number is treated as a number, and every
value that looks like a <a href="ref/expr.html#boolean-values">boolean</a> is treated as a boolean.</p>
<p>The <a href="ref/expr.html#operators-and-precedence">operators</a> permitted in expressions include most of those
permitted in C expressions, with a few additional ones  The operators have the same
meaning and precedence as in C.  Expressions can yield numeric or non-numeric results.</p>
<p>Integer computations are done with Rust's <code>i64</code> type; floating-point computations are
done with Rust's <code>f64</code> type.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<pre><code class="language-tcl">expr {1 + 1}

set x 7.5
set y 3.4
expr {$x + $y}

expr {[mycommand] + 2}

expr {2*(1 + abs($x))}
</code></pre>
<h2 id="operators-and-precedence"><a class="header" href="#operators-and-precedence">Operators and Precedence</a></h2>
<p>The following table shows the operators in order of precedence.</p>
<div class="table-wrapper"><table><thead><tr><th>Operators</th><th>Details</th></tr></thead><tbody>
<tr><td><code>- + ~ !</code></td><td>Unary plus, minus, bit-wise not, and logical not</td></tr>
<tr><td><code>* / %</code></td><td>Multiplication, division, integer remainder</td></tr>
<tr><td><code>+ -</code></td><td>Addition, subtraction</td></tr>
<tr><td><code>&lt;&lt; &gt;&gt;</code></td><td>Left and right shift.</td></tr>
<tr><td><code>&lt; &gt; &lt;= &gt;=</code></td><td>Ordering relations (see below)</td></tr>
<tr><td><code>== !=</code></td><td>Equality, inequality (see below)</td></tr>
<tr><td><code>eq ne</code></td><td>String equality, inequality</td></tr>
<tr><td><code>in ni</code></td><td>List inclusion, exclusion</td></tr>
<tr><td><code>&amp;</code></td><td>Bit-wise AND</td></tr>
<tr><td><code>^</code></td><td>Bit-wise exclusive OR</td></tr>
<tr><td><code>|</code></td><td>Bit-wise OR</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>Logical AND, short circuiting</td></tr>
<tr><td><code>||</code></td><td>Logical OR, short circuiting</td></tr>
<tr><td><code>x ? y : z</code></td><td>Ternary "if-then-else" operator.</td></tr>
</tbody></table>
</div>
<h2 id="boolean-values"><a class="header" href="#boolean-values">Boolean Values</a></h2>
<ul>
<li>True values: any non-zero number, <code>true</code>, <code>yes</code>, <code>on</code>.</li>
<li>False values: zero, <code>false</code>, <code>no</code>, <code>off</code>.</li>
<li>Logical operators always return 0 or 1.</li>
<li>By convention, predicate commands also return 0 or 1.</li>
</ul>
<h2 id="math-functions"><a class="header" href="#math-functions">Math Functions</a></h2>
<p>Functions are written as "<em>name</em>(<em>argument</em>,...)".  Each argument is itself a complete
expression.</p>
<p>The following functions are available in Molt expressions:</p>
<p><strong>abs(<em>x</em>)</strong> â€” Absolute value of <em>x</em>.</p>
<p><strong>double(<em>x</em>)</strong> â€” Returns integer <em>x</em> as a floating-point value.</p>
<p><strong>int(<em>x</em>)</strong> â€” Truncates floating-point value <em>x</em> and returns it as an integer.</p>
<p><strong>round(<em>x</em>)</strong> â€” Rounds floating-point value <em>x</em> to the nearest integer and returns it as
an integer.</p>
<h2 id="tcl-liens-3"><a class="header" href="#tcl-liens-3">TCL Liens</a></h2>
<p><strong>Expr Command Syntax:</strong> In standard TCL <code>expr</code> takes any number of arguments, which it
concatenates into a single expression for evaluation.  This means that variable and command
interpolation is done twice, once by the TCL parser and once by <code>expr</code>, which hurts
performance and can also be a source of subtle and confusing errors.  Consequently it is
almost always best to provide the expression as a single braced string, and so Molt's <code>expr</code>
takes a single argument.  This is unlikely to change.</p>
<p><strong>Expression Syntax:</strong> Molt's expression parsing is meant to be consistent with TCL 7.6, with the
addition of the TCL 8.x <code>eq</code>, <code>ne</code>, <code>in</code>, and <code>ni</code> operators.</p>
<ul>
<li>Molt does not yet support the full range of math functions supported by TCL 7.6.</li>
<li>Molt does not yet do precise float-to-string-to-float conversions, per TCL 8.6.  See<br />
"String Representation of Floating Point Numbers" on the Tcler's Wiki expr page.</li>
<li>Molt's handling of floating point arithmetic errors is still naive.</li>
</ul>
<p><strong>Integer Division:</strong> Integer division in Molt rounds down towards zero, following the example
of Rust, Python, C99, and many other languages.  Standard TCL rounds toward negative
infinity, a decision that dates to a time when the C standard did not define the correct
behavior and C compilers varied.  It seems reasonable that an extension language should do
something as basic as this in the same way as the host language.</p>
<p><strong>Possible Futures:</strong> The following TCL 8.6 features are not on the road map at present,
but might be added in the future.</p>
<ul>
<li>Bignums</li>
<li>The exponential operator, <code>**</code></li>
<li>The <code>tcl::mathfunc::</code> namespace, and the ability to define new functions in TCL code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for----for-loop"><a class="header" href="#for----for-loop">for -- "For" loop</a></h1>
<p><strong>Syntax: for <em>start</em> <em>test</em> <em>next</em> <em>command</em></strong></p>
<p>The <code>for</code> command provides a C-like "for" loop, where <em>start</em> is a script that initializes the
loop counter, <em>test</em> is a conditional expression, <em>next</em> is a script that updates the loop
counter, and <em>command</em> is the body script.</p>
<p>If the <em>command</em> script calls the <a href="ref/./break.html"><strong>break</strong></a> command, the loop terminates
immediately; if the <em>command</em> script calls the <a href="ref/./continue.html"><strong>continue</strong></a> command,
loop execution continues with the next iteration.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>For example, the following loop counts from 0 to 9:</p>
<pre><code class="language-tcl">for {set i 0} {$i &lt; 10} {incr i} {
    puts "i=$i"
}
</code></pre>
<p>Note, though, that the <em>start</em> and <em>next</em> arguments are arbitrary scripts; for example, <em>start</em>
can initialize multiple variables, and <em>next</em> can update multiple variables.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreach----for-each-loop"><a class="header" href="#foreach----for-each-loop">foreach -- "For each" loop</a></h1>
<p><strong>Syntax: foreach <em>varList</em> <em>list</em> <em>body</em></strong></p>
<p>Loops over the elements in the <em>list</em>, assigning them to the variables
in the <em>varList</em> and executing the <em>body</em> for each set of assignments.</p>
<p>The <a href="ref/./break.html">break</a> and <a href="ref/./continue.html">continue</a> commands can be
used to control loop execution; see their reference pages for details.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>Prints out the values "1", "2", and "3" on successive lines.</p>
<pre><code class="language-Tcl">foreach a {1 2 3} {
    puts $a
}
</code></pre>
<p>Prints out pairs of values from the list. In the final iteration there
is only value left, so <code>b</code> is assigned the empty string.</p>
<pre><code class="language-Tcl">foreach {a b} {1 2 3 4 5} {
    puts "$a,$b"
}
# Outputs:
#
#  1,2
#  3,4
#  5,
</code></pre>
<h2 id="tcl-liens-4"><a class="header" href="#tcl-liens-4">TCL Liens</a></h2>
<p>In standard TCL, <code>foreach</code> can iterate over multiple lists at the
same time, e.g., the following script will output the pairs "a,1",
"b,2", and "c,3".  Molt doesn't currently support this extended syntax.</p>
<pre><code class="language-Tcl">foreach x {a b c} y {1 2 3} {
    puts "$x,$y"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global----bring-global-into-scope"><a class="header" href="#global----bring-global-into-scope">global -- Bring global into scope</a></h1>
<p><strong>Syntax: global ?<em>varname</em> ...?</strong></p>
<p>Brings global variable(s) <em>varname</em> into scope in a
<a href="ref/./proc.html"><code>proc</code></a> body.  This command has no effect if called in the
global scope.</p>
<h2 id="tcl-differences"><a class="header" href="#tcl-differences">TCL Differences</a></h2>
<p>At the script level, <code>global</code> works the same in Molt as in Standard
TCL.  However, Molt's internal implementation of variables is currently much
simpler than standard TCL's, e.g., no arrays, no namespaces.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if----ifthenelse"><a class="header" href="#if----ifthenelse">if -- If/then/else</a></h1>
<p><strong>Syntax: if <em>expr1</em> ?then? <em>body1</em> elseif <em>expr2</em> ?then? <em>body2</em> elseif ... ?else? ?<em>bodyN</em>?</strong></p>
<p>Tests a chain of one or more expressions, and executes the matching <em>body</em>,
which must be a script.  Returns the result of the last command executed in
the selected <em>body</em>.</p>
<p>Both the <code>then</code> and <code>else</code> keywords are optional.  The standard TCL
convention is to always omit the <code>then</code> keywords and to always
include the <code>else</code> keyword when there's an <code>else</code> clause.</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<pre><code class="language-tcl">if {$x &gt; 0} {
    puts "positive"
}

if {$x &lt; 0} {
    puts "negative"
} else {
    puts "non-negative"
}

if {$x &gt; 0} {
    puts "positive"
} elseif {$x &lt; 0} {
    puts "negative"
} else {
    puts "zero"
}

set value [if {$x &gt; 0} {
    expr {$x + $y}   
} else {
    expr {$x - $y}   
}]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incr----increment-integer"><a class="header" href="#incr----increment-integer">incr -- Increment integer</a></h1>
<p><strong>Syntax: incr <em>varName</em> ?<em>increment</em>?</strong></p>
<p>Increments integer-valued-variable <em>varName</em> by the given <em>increment</em>, which defaults to 1.
If the variable is unset, it is set to the <em>increment</em>.  The command returns the incremented
value.</p>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<pre><code class="language-tcl">unset a
incr a    ;# =&gt; 1
incr a    ;# =&gt; 2
incr a 3  ;# =&gt; 5

for {set a 1} {$a &lt; 10} {incr a} {
    ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="info----interpreter-introspection"><a class="header" href="#info----interpreter-introspection">info -- Interpreter introspection</a></h1>
<p><strong>Syntax: info <em>subcommand</em> ?<em>arg</em> ...?</strong></p>
<p>Returns information about the state of the Molt interpreter.</p>
<div class="table-wrapper"><table><thead><tr><th>Subcommand</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="ref/info.html#info-args">info args</a></td><td>Names of procedure's arguments</td></tr>
<tr><td><a href="ref/info.html#info-body">info body</a></td><td>Gets procedure body</td></tr>
<tr><td><a href="ref/info.html#info-cmdtype">info cmdtype</a></td><td>Queries a command's type</td></tr>
<tr><td><a href="ref/info.html#info-commands">info commands</a></td><td>Names of all defined commands</td></tr>
<tr><td><a href="ref/info.html#info-complete">info complete</a></td><td>Is this string a syntactically complete command?</td></tr>
<tr><td><a href="ref/info.html#info-default">info default</a></td><td>A procedure argument's default value</td></tr>
<tr><td><a href="ref/info.html#info-exists">info exists</a></td><td>Is this a variable in the current scope?</td></tr>
<tr><td><a href="ref/info.html#info-globals">info globals</a></td><td>Names of all variables in the global scope</td></tr>
<tr><td><a href="ref/info.html#info-locals">info locals</a></td><td>Names of all local variables in the current scope</td></tr>
<tr><td><a href="ref/info.html#info-procs">info procs</a></td><td>Names of all defined procedures</td></tr>
<tr><td><a href="ref/info.html#info-vars">info vars</a></td><td>Names of all variables in the current scope</td></tr>
</tbody></table>
</div>
<h2 id="info-args"><a class="header" href="#info-args">info args</a></h2>
<p><strong>Syntax: info args <em>procname</em></strong></p>
<p>Retrieves a list of the names of the arguments of the named procedure.  Returns an error
if the command is undefined or is a binary command.</p>
<p>For example,</p>
<pre><code class="language-tcl">% proc myproc {a b c} { ... }
% info args myproc
a b c
%
</code></pre>
<h2 id="info-body"><a class="header" href="#info-body">info body</a></h2>
<p><strong>Syntax: info body <em>procname</em></strong></p>
<p>Retrieves the body of the named procedure.  Returns an error if the command is undefined or
is a binary command.</p>
<p>For example,</p>
<pre><code class="language-tcl">% proc myproc {name} { puts "Hello, $name" }
% info body myproc
puts "Hello, $name"
%
</code></pre>
<h2 id="info-cmdtype"><a class="header" href="#info-cmdtype">info cmdtype</a></h2>
<p><strong>Syntax: info cmdtype <em>command</em></strong></p>
<p>Retrieves the named command's type, either <code>native</code> or <code>proc</code>.  The <em>command</em> is <code>native</code> if it's
implemented in Rust and <code>proc</code> if it's implemented as a TCL procedure.</p>
<pre><code class="language-tcl">% proc myproc {} { ... }
% info cmdtype set
native
% info cmdtype myproc
proc
%
</code></pre>
<p><strong>TCL Liens</strong>: Standard TCL defines a variety of other command types, e.g., slave interpreters,
interpreter aliases, objects, and so forth.  These will be added naturally if and when they are
added to Molt.</p>
<h2 id="info-commands"><a class="header" href="#info-commands">info commands</a></h2>
<p><strong>Syntax: info commands</strong></p>
<p>Returns an unsorted list of the names of the commands defined in the interpreter,
including both binary commands and procedures.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<h2 id="info-complete"><a class="header" href="#info-complete">info complete</a></h2>
<p><strong>Syntax: info complete <em>command</em></strong></p>
<p>Returns 1 if the command appears to be a complete Tcl command, i.e., it
has no unmatched quotes, braces, or brackets, and 0 otherwise.  REPLs can
use this to allow the user to build up a multi-line command.</p>
<p>For example,</p>
<pre><code class="language-tcl">% info complete { puts "Hello, world!" }
1
% info complete { puts "Hello, world! }
0
%
</code></pre>
<h2 id="info-default"><a class="header" href="#info-default">info default</a></h2>
<p><strong>Syntax: info default <em>procname</em> <em>arg</em> <em>varname</em></strong></p>
<p>Retrieves the default value of procedure <em>procname</em>'s argument called <em>arg</em>.  If <em>arg</em> has
a default value, <code>info default</code> returns 1 and assigns the default value to the variable
called <em>varname</em>.  Otherwise, <code>info default</code> returns 0 and assigns the empty string to the
variable called <em>varname</em>.</p>
<p>The command throws an error if:</p>
<ul>
<li><em>procname</em> doesn't name a procedure</li>
<li>The procedure <em>procname</em> has no argument called <em>arg</em></li>
<li>The value can't be assigned to a variable called <em>varname</em>.</li>
</ul>
<p>In the following example, <code>myproc</code> has two arguments, <code>a</code> and <code>b</code>.  <code>a</code> has no default value;
<code>b</code> has the default value <code>Howdy</code>.</p>
<pre><code class="language-tcl">% proc myproc {a {b Howdy}} { ... }
% info default myproc a defvalue
0
% puts "&lt;$defval&gt;"
&lt;&gt;
% info default myproc b defvalue
1
% puts "&lt;$defval&gt;"
&lt;Howdy&gt;
%
</code></pre>
<h2 id="info-exists"><a class="header" href="#info-exists">info exists</a></h2>
<p><strong>Syntax: info exists <em>varname</em></strong></p>
<p>Returns 1 if <em>varname</em> is the name of a variable or array element in the current scope, and
0 otherwise.</p>
<pre><code class="language-tcl">% set a 1
1
% set b(1) 1
1
% info exists a
1
% info exists b
1
% info exists c
0
% info exists b(1)
1
% info exists b(2)
0
</code></pre>
<h2 id="info-globals"><a class="header" href="#info-globals">info globals</a></h2>
<p><strong>Syntax: info globals</strong></p>
<p>Returns an unsorted list of the names of all variables defined in the global scope.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<h2 id="info-locals"><a class="header" href="#info-locals">info locals</a></h2>
<p><strong>Syntax: info locals</strong></p>
<p>Returns an unsorted list of the names of all local variables defined in the current scope, e.g.,
<code>proc</code> arguments and variables defined locally, but no variables brought in from other scopes
via <code>global</code> or <code>upvar</code>.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<h2 id="info-procs"><a class="header" href="#info-procs">info procs</a></h2>
<p><strong>Syntax: info procs</strong></p>
<p>Returns an unsorted list of the names of the procedures defined in the interpreter,
omitting binary commands.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<h2 id="info-vars"><a class="header" href="#info-vars">info vars</a></h2>
<p><strong>Syntax: info vars</strong></p>
<p>Returns an unsorted list of the names of all variables that are visible
in the current scope, whether global or local.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join----join-list-elements-into-a-string"><a class="header" href="#join----join-list-elements-into-a-string">join -- Join list elements into a string</a></h1>
<p><strong>Syntax: join <em>list</em> ?<em>joinString</em>?</strong></p>
<p>Joins the elements of a list into a string, including the <em>joinString</em>
in between each element.  If not given, the <em>joinString</em> defaults to
a single space character.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lindex----index-into-a-list"><a class="header" href="#lindex----index-into-a-list">lindex -- Index into a list</a></h1>
<p><strong>Syntax: lindex <em>list</em> ?<em>index</em> ...?</strong></p>
<p>Returns an element from the <em>list</em>, indexing into nested lists.  The indices
may be represented as individual indices on the command line, or as a list
of indices.  Indices are integers from 0 to length - 1.  If an index is less
than 0 or greater than or equal to the list length, <code>lindex</code> will return
the empty string.</p>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<pre><code class="language-tcl">lindex {a {b c d} e}        ;# "a {b c d} e"
lindex {a {b c d} e} 1      ;# "b c d"
lindex {a {b c d} e} 1 1    ;# "c"
lindex {a {b c d} e} {}     ;# "a {b c d} e"
lindex {a {b c d} e} {1 1}  ;# "c"
</code></pre>
<h2 id="tcl-liens-5"><a class="header" href="#tcl-liens-5">TCL Liens</a></h2>
<p>Indices in standard TCL may take several additional forms.  For example,
<code>end</code> indexes the last entry in the list; <code>end-1</code> indexes the next to last
entry, and so forth.  Molt doesn't yet support this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list----create-a-list"><a class="header" href="#list----create-a-list">list -- Create a list</a></h1>
<p><strong>Syntax: list ?<em>arg</em> ...?</strong></p>
<p>Returns a list whose elements are the given arguments.  The list will
be in canonical list form.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="llength----length-of-a-list"><a class="header" href="#llength----length-of-a-list">llength -- Length of a list</a></h1>
<p><strong>Syntax: llength <em>list</em></strong></p>
<p>Returns the length of the list.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proc----procedure-definition"><a class="header" href="#proc----procedure-definition">proc -- Procedure definition</a></h1>
<p><strong>Syntax: proc <em>name</em> <em>args</em> <em>body</em></strong></p>
<p>Defines a procedure with the given <em>name</em>, argument list <em>args</em>, and
script <em>body</em>.  The procedure may be called like any built-in command.</p>
<p>The argument list, <em>args</em>, is a list of argument specifiers, each of
which may be:</p>
<ul>
<li>A name, representing a required argument</li>
<li>A list of two elements, a name and a default value, representing an
optional argument</li>
<li>The name <code>args</code>, representing any additional arguments.</li>
</ul>
<p>Optional arguments must follow required arguments, and <code>args</code> must
appear last.</p>
<p>When called, the procedure returns the result of the last command in the
body script, or the result of calling <a href="ref/./return.html"><code>return</code></a>, or an
error.</p>
<h2 id="tcl-liens-6"><a class="header" href="#tcl-liens-6">TCL Liens</a></h2>
<p>Molt does not support namespaces or namespace syntax in procedure names.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="puts----print-a-string"><a class="header" href="#puts----print-a-string">puts -- Print a string</a></h1>
<p><strong>Syntax: puts <em>string</em></strong></p>
<p>Outputs the <em>string</em> to standard output.</p>
<h2 id="tcl-liens-7"><a class="header" href="#tcl-liens-7">TCL Liens</a></h2>
<ul>
<li>Does not support <code>-nonewline</code></li>
<li>Does not support <code>?channelId?</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rename----rename-a-command"><a class="header" href="#rename----rename-a-command">rename -- Rename a command</a></h1>
<p><strong>Syntax: rename <em>oldName</em> <em>newName</em></strong></p>
<p>Renames the command called <em>oldName</em> to be <em>newName</em> instead.</p>
<p>Any command may be renamed in this way; it is a common TCL approach to wrap a command by
renaming it and defining a new command with the <em>oldName</em> that calls the old command at
its <em>newName</em>.</p>
<p>If the <em>newName</em> is the empty string, the command will be removed from the interpreter.</p>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<pre><code class="language-tcl">proc myproc {} { ... }

# Rename the proc
rename myproc yourproc

# Remove the proc from the interpreter
rename yourproc ""
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return----return-a-value"><a class="header" href="#return----return-a-value">return -- Return a value</a></h1>
<p><strong>Syntax: return ?<em>options</em>? ?<em>value</em>?</strong></p>
<p>Returns from a TCL procedure or script, optionally including a value.  By default, the
command simply returns the given <em>value</em>, or the empty string if <em>value</em> is omitted.</p>
<pre><code class="language-tcl">proc just_return {} {
    ...
    if {$a eq "all done"} {
        # Just return.  The return value will be the empty string, ""
        return
    }
    ...
}

proc identity {x} {
    # Return the argument
    return $x
}
</code></pre>
<p>The options allow the caller to return any TCL return code and to return through multiple
procedures at once.  The options are as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td>-code <em>code</em></td><td>The TCL result code; defaults to <code>ok</code>.</td></tr>
<tr><td>-level <em>level</em></td><td>Number of stack levels to return through; defaults to 1.</td></tr>
<tr><td>-errorcode <em>errorCode</em></td><td>The error code, when <code>-code</code> is <code>error</code>. Defaults to <code>NONE</code>.</td></tr>
<tr><td>-errorinfo <em>errorInfo</em></td><td>The initial error stack trace. Defaults to the empty string.</td></tr>
</tbody></table>
</div>
<h2 id="the--code-and--level-options"><a class="header" href="#the--code-and--level-options">The <code>-code</code> and <code>-level</code> Options</a></h2>
<p>The <code>-code</code> and <code>-level</code> options work together.  The semantics are tricky to understand; a good
aid is to try things and use <a href="ref/catch.html"><strong>catch</strong></a> to review the result value and options.</p>
<p>If <code>-code</code> is given, the <em>code</em> must be one of <code>ok</code> (the default), <code>error</code>, <code>return</code>, <code>break</code>,
<code>continue</code>, or an integer. Integer codes 0, 1, 2, 3, and 4 correspond to the symbolic constants
just given.  Other integers can be used to implement application-specific control structures.</p>
<p>If <code>-level</code> is given, the <em>level</em> must be an integer greater than or equal to zero; it represents
the number of stack levels to return through, and defaults to <code>1</code>.</p>
<p>Because of the defaults, a bare <code>return</code> is equivalent to <code>return -code ok -level 1</code>:</p>
<pre><code class="language-tcl"># These are the same:
proc simple {}  { return "Hello world" }
proc complex {} { return -code ok -level 1 "Hello world" }
</code></pre>
<p>Both tell the interpreter to return "Hello world" to caller the caller of the current procedure
as a normal (<code>ok</code>) return value.</p>
<p>By selecting a different <code>-code</code>, one can return some other error code.  For example,
<code>break</code> and <code>return -code break -level 0</code> are equivalent.  This can be useful in several ways. For
example, suppose you want to extend the language to support <code>break</code> and <code>continue</code> with labels,
to be used with some new control structure.  You could do the following; note the <code>-level 1</code>.  The
<code>return</code> command returns from your <code>labeled_break</code> procedure to its caller, where it is understood
as a <code>break</code> result.</p>
<pre><code class="language-tcl">proc labeled_break {{label ""}} {
    return -code break -level 1 $label
}
</code></pre>
<p>Your new control structure would [<strong>catch</strong>] the result, see that it's a <code>break</code>, and jump to
the indicated label.</p>
<p>Similarly, suppose you want to write a command that works like <code>return</code> but does some additional
processing. You could do the following; note the <code>-level 2</code>.  The <code>2</code> is because the command needs
to return from your <code>list_return</code> method, and <em>then</em> from the calling procedure: two stack levels.</p>
<pre><code class="language-tcl"># Return arguments as a list
proc list_return {a b c} {
    return -level 2 -code ok [list a b c]
}
</code></pre>
<h2 id="returning-errors-cleanly"><a class="header" href="#returning-errors-cleanly">Returning Errors Cleanly</a></h2>
<p>The normal way to throw an error in TCL is to use either the <a href="ref/error.html"><strong>error</strong></a> or
<a href="ref/throw.html"><strong>throw</strong></a> command; the latter is used in more modern code when there's an explicit
error code.  However, both of these commands will appear in the error stack trace.</p>
<p>Some TCL programmers consider it good style in library code to throw errors using <code>return</code>, as
follows (with or without the <code>-errorcode</code>):</p>
<pre><code class="language-tcl">proc my_library_proc {} {
   ...
   return -code error -level 1 -errorcode {MYLIB MYERROR} "My Error Message"
}
</code></pre>
<p>The advantage of this approach is that the stack trace will show <code>my_library_proc</code> as the source
of the error, rather than <code>error</code> or <code>catch</code>.</p>
<h2 id="the--errorinfo-option-and-re-throwing-errors"><a class="header" href="#the--errorinfo-option-and-re-throwing-errors">The <code>-errorinfo</code> Option and Re-throwing Errors</a></h2>
<p>Sometimes it's desirable to catch an error, take some action (e.g., log it), and then rethrow
it.  The <code>return</code> command is used to do this:</p>
<pre><code>set code [catch {
    # Some command or script that can throw an error
} result opts]

if {$code == 1} {
    # Log the error message
    puts "Got an error: $result"

    # Rethrow the error by returning with exactly the options and return
    # result that we received.
    return {*}$opts $result
}
</code></pre>
<h2 id="tcl-liens-8"><a class="header" href="#tcl-liens-8">TCL Liens</a></h2>
<p>The standard TCL <code>return</code> command is more complicated than shown here; however, the Molt
implementation provides all of the useful patterns the author has ever seen in use.  Some of the
specific differences are as follows:</p>
<ul>
<li>
<p>Molt rejects any options other than the ones listed above, and ignores <code>-errorcode</code> and
<code>-errorinfo</code> if the <code>-code</code> is anything other than <code>error</code>.  Standard TCL's <code>return</code> retains all
option/value pairs it is given, to be included in the <code>catch</code> options.</p>
</li>
<li>
<p>Standard TCL's <code>return</code> takes an <code>-options</code> option; in Standard TCL, <code>return -options $opts</code>
is equivalent to <code>return {*}$ops</code>.  Molt doesn't support <code>-options</code>, as it doesn't add any
value and is confusing.</p>
</li>
<li>
<p>Standard TCL provides two versions of the stack trace: the "error info", meant to be human
readable, and the "error stack", for programmatic use.  The <code>-errorstack</code> is used to
initialize the error stack when rethrowing errors, as <code>-errorinfo</code> is used to initialize the
error info string.  Molt does not support the error stack at this time.</p>
</li>
</ul>
<p>Some of these liens may be reconsidered over time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set----set-a-variables-value"><a class="header" href="#set----set-a-variables-value">set -- Set a variable's value</a></h1>
<p><strong>Syntax: set <em>varName</em> ?<em>newValue</em>?</strong></p>
<p>Sets variable <em>varName</em> to the <em>newValue</em>, returning the <em>newValue</em>.  If
<em>newValue</em> is omitted, simply returns the variable's existing value, or
returns an error if there is no existing value.</p>
<p>The <code>set</code> command operates in the current scope, e.g., in
<a href="ref/./proc.html"><code>proc</code></a> bodies it operates on the set of local variables.</p>
<p>See also: <a href="ref/./global.html"><code>global</code></a></p>
<h2 id="tcl-liens-9"><a class="header" href="#tcl-liens-9">TCL Liens</a></h2>
<ul>
<li>Molt does not support namespaces or namespace notation.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source----evaluate-a-script-file"><a class="header" href="#source----evaluate-a-script-file">source -- Evaluate a script file</a></h1>
<p><strong>Syntax: source <em>filename</em></strong></p>
<p>Executes the named file as a Molt script, returning the result of the final
command executed in the script.</p>
<h2 id="tcl-differences-1"><a class="header" href="#tcl-differences-1">TCL Differences</a></h2>
<ul>
<li>
<p>Standard TCL provides a <code>-encoding</code> option, for choosing a specific
Unicode encoding. Molt assumes that the text read from the file is
in the UTF-8 encoding, and does nothing special about it.</p>
</li>
<li>
<p>Standard TCL reads from the <code>source</code>'d file only up to the first ^Z.<br />
This allows for the creation of scripted documents: binary files beginning
with a TCL script.  The script can then open the file and read the rest
of the data.  Molt does not implement this behavior.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string----string-manipulation"><a class="header" href="#string----string-manipulation">string -- String manipulation</a></h1>
<p><strong>Syntax: string <em>subcommand</em> ?<em>args</em>...?</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Subcommand</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="ref/string.html#string-cat">string cat</a></td><td>Concatenates zero or more strings</td></tr>
<tr><td><a href="ref/string.html#string-compare">string compare</a></td><td>Compares two strings lexicographically</td></tr>
<tr><td><a href="ref/string.html#string-equal">string equal</a></td><td>Compares two strings for equality</td></tr>
<tr><td><a href="ref/string.html#string-first">string first</a></td><td>Finds first occurrence of a string</td></tr>
<tr><td><a href="ref/string.html#string-last">string last</a></td><td>Finds last occurrence of a string</td></tr>
<tr><td><a href="ref/string.html#string-length">string length</a></td><td>String length in characters</td></tr>
<tr><td><a href="ref/string.html#string-map">string map</a></td><td>Maps keys to values in a string</td></tr>
<tr><td><a href="ref/string.html#string-range">string range</a></td><td>Extracts a substring</td></tr>
<tr><td><a href="ref/string.html#string-tolower">string tolower</a></td><td>Converts a string to lower case</td></tr>
<tr><td><a href="ref/string.html#string-toupper">string toupper</a></td><td>Converts a string to upper case</td></tr>
<tr><td><a href="ref/string.html#string-trim">string trim</a></td><td>Trims leading and trailing whitespace</td></tr>
<tr><td><a href="ref/string.html#string-trimleft">string trimleft</a></td><td>Trims leading whitespace</td></tr>
<tr><td><a href="ref/string.html#string-trimright">string trimright</a></td><td>Trims trailing whitespace</td></tr>
</tbody></table>
</div>
<h2 id="tcl-liens-10"><a class="header" href="#tcl-liens-10">TCL Liens</a></h2>
<ul>
<li>Supports a subset of the subcommands provided by the standard TCL <code>string</code> command.  The
subset will increase over time.</li>
<li>Does not currently support index syntax, e.g., <code>end-1</code>, for the <code>string first</code>,
<code>string last</code>, and <code>string range</code> commands.  These commands accept simple numeric indices only.</li>
</ul>
<h2 id="molt-strings-and-unicode"><a class="header" href="#molt-strings-and-unicode">Molt Strings and Unicode</a></h2>
<p>Molt strings are exactly and identically Rust <code>String</code> values, and are treated at the TCL
level as vectors of Rust <code>char</code> values. A Rust <code>char</code> is a "Unicode scalar value", and is
also (in most cases) a Unicode code point.  It is not a not a grapheme; graphemes that
consist of multiple code points will be treated as multiple characters.  This is more or
less the same as Standard TCL, but Unicode being what it is there may be edge cases where
behavior will differ slightly.</p>
<h2 id="string-cat"><a class="header" href="#string-cat">string cat</a></h2>
<hr />
<p><strong>Syntax: string cat ?<em>args</em> ...?</strong></p>
<p>Returns the concatenation of zero or more strings.</p>
<h2 id="string-compare"><a class="header" href="#string-compare">string compare</a></h2>
<hr />
<p><strong>Syntax: string compare ?<em>options</em>? <em>string1</em> <em>string2</em></strong></p>
<p>Compares the two strings lexicographically, returning <code>-1</code> if <em>string1</em> is less than <em>string2</em>,
<code>0</code> if they are equal, and <code>1</code> if <em>string1</em> is greater than <em>string2</em>.</p>
<p>The options are as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td>-nocase</td><td>The comparison is case-insensitive.</td></tr>
<tr><td>-length <em>length</em></td><td>Only the first <em>length</em> characters will be compared.</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>When <code>-nocase</code> is given, the strings are compared by converting them to lowercase using
a naive method that may fail for more complex Unicode graphemes.</li>
</ul>
<h2 id="string-equal"><a class="header" href="#string-equal">string equal</a></h2>
<hr />
<p><strong>Syntax: string equal ?<em>options</em>? <em>string1</em> <em>string2</em></strong></p>
<p>Compares the two strings, returning <code>1</code> if they are equal, and <code>0</code> otherwise.</p>
<p>The options are as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td>-nocase</td><td>The comparison is case-insensitive.</td></tr>
<tr><td>-length <em>length</em></td><td>Only the first <em>length</em> characters will be compared.</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>When <code>-nocase</code> is given, the strings are compared by converting them to lowercase using
a naive method that may fail for more complex Unicode graphemes.</li>
</ul>
<h2 id="string-first"><a class="header" href="#string-first">string first</a></h2>
<hr />
<p><strong>Syntax: string first <em>needleString haystackString</em> ?<em>startIndex</em>?</strong></p>
<p>Returns the index of the first occurrence of the <em>needleString</em> in the <em>haystackString</em>, or
-1 if the <em>needleString</em> is not found.  If the <em>startIndex</em> is given, the search will begin
at the <em>startIndex</em>.</p>
<h2 id="string-last"><a class="header" href="#string-last">string last</a></h2>
<hr />
<p><strong>Syntax: string last <em>needleString haystackString</em> ?<em>startIndex</em>?</strong></p>
<p>Returns the index of the last occurrence of the <em>needleString</em> in the <em>haystackString</em>, or
-1 if the <em>needleString</em> is not found.  If the <em>startIndex</em> is given, the search will begin
at the <em>startIndex</em>.</p>
<h2 id="string-length"><a class="header" href="#string-length">string length</a></h2>
<hr />
<p><strong>Syntax: string length <em>string</em></strong></p>
<p>Returns the length of the string in Rust characters.</p>
<h2 id="string-map"><a class="header" href="#string-map">string map</a></h2>
<hr />
<p><strong>Syntax: string map ?-nocase? <em>mapping string</em></strong></p>
<p>Replaces old substrings in <em>string</em> with new ones based on the key/value pairs in <em>mapping</em>,
which is a dictionary or flat key/value list.  If <code>-nocase</code> is given, substring matches will
be case-insensitive.  The command iterates through the string in a single pass, checking for
each key in order, so that earlier key replacements have no effect on later key replacements.</p>
<h2 id="string-range"><a class="header" href="#string-range">string range</a></h2>
<hr />
<p><strong>Syntax: string range <em>string</em> <em>first</em> <em>last</em></strong></p>
<p>Returns the substring of <em>string</em> starting with the character whose index is <em>first</em> and
ending with the character whose index is <em>last</em>.  Values of <em>first</em> that are less than 0 are
treated as 0, and values of <em>last</em> that are greater than the index of the last character in the
string are treated as that index.</p>
<h2 id="string-tolower"><a class="header" href="#string-tolower">string tolower</a></h2>
<hr />
<p><strong>Syntax: string tolower <em>string</em></strong></p>
<p>Converts the <em>string</em> to all lower case, using the standard Rust <code>String::to_lowercase</code> method.</p>
<p><strong>TCL Liens</strong>: Tcl 8.6 provides for optional <em>first</em> and <em>last</em> indices; only the text in that
range is affected.</p>
<h2 id="string-toupper"><a class="header" href="#string-toupper">string toupper</a></h2>
<hr />
<p><strong>Syntax: string toupper <em>string</em></strong></p>
<p>Converts the <em>string</em> to all upper case, using the standard Rust <code>String::to_uppercase</code> method.</p>
<p><strong>TCL Liens</strong>: Tcl 8.6 provides for optional <em>first</em> and <em>last</em> indices; only the text in that
range is affected.</p>
<h2 id="string-trim"><a class="header" href="#string-trim">string trim</a></h2>
<hr />
<p><strong>Syntax: string trim <em>string</em></strong></p>
<p>Returns <em>string</em> trimmed of leading and trailing whitespace by the standard Rust <code>String::trim</code>
method.</p>
<h2 id="string-trimleft"><a class="header" href="#string-trimleft">string trimleft</a></h2>
<hr />
<p><strong>Syntax: string trimleft <em>string</em></strong></p>
<p>Returns <em>string</em> trimmed of leading whitespace by the standard Rust <code>String::trim_start</code>
method.</p>
<h2 id="string-trimright"><a class="header" href="#string-trimright">string trimright</a></h2>
<hr />
<p><strong>Syntax: string trimright <em>string</em></strong></p>
<p>Returns <em>string</em> trimmed of trailing whitespace by the standard Rust <code>String::trim_end</code>
method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="throw----throws-an-exception"><a class="header" href="#throw----throws-an-exception">throw -- Throws an exception</a></h1>
<p><strong>Syntax: throw <em>type</em> <em>message</em></strong></p>
<p>Throws an error with error code <em>type</em> and the given error <em>message</em>.  The error may
be caught using the <a href="ref/./catch.html"><strong>catch</strong></a> command.</p>
<p>The error code is usually defined as a TCL list of symbols, e.g., <code>ARITH DIVZERO</code>.  Most standard
TCL error codes begin with <code>ARITH</code> (for arithmetic errors) or <code>TCL</code>.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><code class="language-tcl">proc myproc {x} {
    if {$x &lt; 0} {
        throw NEGNUM "input must be non-negative"
    }
    ...
}
</code></pre>
<p>Note that the <a href="ref/./error.html"><strong>error</strong></a> command is equivalent to <code>throw NONE</code>; also, the <code>return</code>
command can also throw an error with an error code.  The three following
commands are semantically identical:</p>
<pre><code class="language-tcl">error "My error message"

throw NONE "My error message"

return -code error -level 0 -errorcode NONE "My error message"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time----time-script-execution"><a class="header" href="#time----time-script-execution">time -- Time script execution</a></h1>
<p><strong>Syntax: time <em>command</em> ?<em>count</em>?</strong></p>
<p>Evaluates the given <em>command</em> the given number of times, or once if no count is specified,
timing each execution.  The average run time in microseconds is returned as a string,
"<em>average</em> microseconds per iteration".</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><code class="language-tcl">% time { mycommand } 1000
15 microseconds per iteration
%
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unset----clear-a-variable"><a class="header" href="#unset----clear-a-variable">unset -- Clear a variable</a></h1>
<p><strong>Syntax: unset ?-nocomplain? ?--? ?<em>name</em> <em>name</em> <em>name</em>...?</strong></p>
<p>Unsets one or more variables whose names are passed to the command.
It does not matter whether the variables actually exist or not.</p>
<p>The <code>-nocomplain</code> option is ignored.  The argument <code>--</code> indicates the
end of options; all arguments following <code>--</code> will be treated as variable
names whether they begin with a hyphen or not.</p>
<h2 id="tcl-differences-2"><a class="header" href="#tcl-differences-2">TCL Differences</a></h2>
<p>In standard TCL, it's an error to unset a variable that doesn't exist; the
command provides the <code>-nocomplain</code> option to cover this case. In Molt,
<code>unset</code> never complains; the <code>-nocomplain</code> option is provided only for
compatible with legacy TCL code.  (Per the TCL Core Team, the <code>-nocomplain</code>
option indicates, wherever it is found, that the original definition of the
command got the default behaviour wrong.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while----while-loop"><a class="header" href="#while----while-loop">while -- "While" loop</a></h1>
<p><strong>Syntax: while <em>test</em> <em>command</em></strong></p>
<p>The <code>while</code> command is a standard "while" loop, executing the <em>command</em> script just so
long as the <em>test</em> expression evaluates to true.</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<p>The following code will output the numbers from 1 to 10.</p>
<pre><code class="language-tcl">set i 0
while {$i &lt; 10} {
    puts "i=[incr i]"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-molt"><a class="header" href="#embedding-molt">Embedding Molt</a></h1>
<p>This chapter explains how to embed Molt in a Rust application.  There are several parts
to this:</p>
<ul>
<li>Creating a Molt interpreter</li>
<li><a href="embed/./commands.html">Defining application-specific Molt commands</a></li>
<li>Invoking the interpreter to <a href="embed/./eval.html">evaluate Molt commands and scripts</a></li>
</ul>
<p>An application may execute scripts for its own purposes and arbitrary scripts defined by
the user.  One common pattern is to define a <a href="embed/./shell.html">shell application</a> the user
may use to execute their own scripts using the application-specific command set.</p>
<p>It is also possible to define <a href="embed/./library.html">Molt library crate</a> that defines commands
for installation into an interpreter.</p>
<p>The initial step, creating a Molt interpreter, is trivially easy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use molt::Interp;

let mut interp = Interp::new();

// Add application-specific commands
<span class="boring">}</span></code></pre></pre>
<p>This creates an interpreter containing the standard set of Molt commands.  Alternatively,
you can create a completely empty interpreter and add just the commands you want:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use molt::Interp;

let mut interp = Interp::empty();

// Add application-specific commands
<span class="boring">}</span></code></pre></pre>
<p>This is useful if you wish to use the Molt interpreter as a safe file parser.</p>
<p>Eventually there will be an API for adding specific standard Molt commands back into an empty
interpreter so that the application can create a custom command set (e.g., including
variable access and control structures but excluding file I/O), but that hasn't yet
been implemented.</p>
<p>We'll cover the remaining topics in the following sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-molt-value-type"><a class="header" href="#the-molt-value-type">The Molt <code>Value</code> Type</a></h1>
<p>The <code>Value</code> type is the standard representation in Rust of Molt values.  In the Tcl
language, "everything is a string"; which is to say, every value can be represented
as a string.  Many valuesâ€”e.g., numbers and listsâ€”also have a binary data representation,
but a single value can move from one binary data representation to another depending
on how it is used by the user.  Consider the following:</p>
<pre><code class="language-tcl">set x [expr {2 + 3}]  ;# It's the integer 5.
puts "x=$x"           ;# It's converted to a string.
set y [lindex $x 0]   ;# It's converted to a one-element list.
</code></pre>
<p>Initially, the variable <code>x</code> contains a <code>Value</code> with only a data representation, the
integer 5.  Then <code>puts</code> needs it as a string, and so the <code>Value</code> acquires a string
representation as well, but retains its integer representation.  Then <code>lindex</code> needs
to look at it as a list, so the string is parsed into a Molt list and the 0th element
is returned.  The integer representation is lost and replaced by the list
representation. The <code>Value</code> type manages all of these transformations internally, with the effect that string-to-binary and binary-to-string conversions happen only when
absolutely necessary.</p>
<p>Note: A <code>Value</code>'s string representation is never lost, once acquired: semantically,
<code>Values</code> are immutable.  The data transformations that go on under the hood are an
aid to performance, but in principle the value is unchanged.</p>
<h2 id="creating-values"><a class="header" href="#creating-values">Creating Values</a></h2>
<p><code>Values</code> can be created easily from a variety of kinds of input:</p>
<pre><code>let a = Value::from("abc");                              // &amp;str
let b = Value::from("def".to_string());                  // String
let c = Value::from(123);                                // MoltInt (i64)
let d = Value::from(45.67);                              // MoltFloat (f64)
let e = Value::from(true);                               // bool
let f = Value::from(&amp;[Value::from(1), Value::from(2)]);  // &amp;[Value]
</code></pre>
<p>And in fact, a <code>Value</code> can contain any Rust type that supports the <code>Display</code>,
<code>Debug</code>, and <code>FromStr</code> types via the <code>Value::from_other</code> method.  Such types are
called "external types" in the Molt documentation set.</p>
<h2 id="cloning-values"><a class="header" href="#cloning-values">Cloning Values</a></h2>
<p>Because <code>Values</code> are immutable, they have been designed to be cheaply and easy cloned
with reference counting via the standard <code>Rc</code> type.</p>
<h2 id="retrieving-data-from-values"><a class="header" href="#retrieving-data-from-values">Retrieving Data from Values</a></h2>
<p>It is always possible to retrieve a <code>Value</code>'s data as a string:</p>
<pre><code>let value = Value::from(5);
let text: String = value.to_string();
assert_eq!(&amp;text, "5");
</code></pre>
<p>The <code>to_string</code> method creates a brand new <code>String</code> in the usual way; it is usually better to
use <code>as_str</code>, which returns an <code>&amp;str</code>:</p>
<pre><code>let value = Value::from(5);
let text = value.as_str();
assert_eq!(text, "5");
</code></pre>
<p>It is also possible to retrieve data representations; but since this isn't guaranteed to
work the relevant methods all return <code>Result&lt;_,ResultCode&gt;</code>.  (See
<a href="embed/./molt_result.html">The <code>MoltResult</code> type</a> for a discussion of <code>ResultCodes</code>.)  For
example,</p>
<pre><code>let value = Value::from("123");
let x = value.as_int()?;
assert_eq!(x, 123);
</code></pre>
<h2 id="retrieving-values-of-external-types"><a class="header" href="#retrieving-values-of-external-types">Retrieving Values of External Types</a></h2>
<p>Values of external types can be retrieved as well using the <code>Value::as_copy</code> or
<code>Value::as_other</code> method, depending on whether the type implements the <code>Copy</code>
trait.  These are different than their peers, in that they return <code>Option&lt;T&gt;</code>
and <code>Option&lt;Rc&lt;T&gt;&gt;</code> rather than <code>Result&lt;T,ResultCode&gt;</code> or <code>Result&lt;Rc&lt;T&gt;,ResultCode&gt;</code>.
The reason is that Molt doesn't know what the appropriate
error message should be when it finds a value it can't convert into the external
type <code>T</code> and so returns <code>None</code>, leaving the error handling up to the client.</p>
<p>For this reason, when using an external type <code>MyType</code> with Molt it is usual to define a
function that converts a <code>Value</code> to a <code>Result&lt;MyType,ResultCode&gt;</code>.  If <code>MyType</code> is an
enum, for example, you might write this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyType {
    /// A convenience: retrieves the enumerated value, converting it from
    /// `Option&lt;MyType&gt;` into `Result&lt;MyType,ResultCode&gt;`.
    pub fn from_molt(value: &amp;Value) -&gt; Result&lt;Self, ResultCode&gt; {
        if let Some(x) = value.as_copy::&lt;MyType&gt;() {
            Ok(x)
        } else {
            Err(ResultCode::Error(Value::from("Not a MyType string")))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-moltresult-type"><a class="header" href="#the-moltresult-type">The MoltResult Type</a></h1>
<p><code>MoltResult</code> is Molt's standard <code>Result&lt;T,E&gt;</code> type; it is defined as</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MoltResult = Result&lt;Value, Exception&gt;;
<span class="boring">}</span></code></pre></pre>
<p>The <code>Value</code> type is described in the <a href="embed/./molt_value.html">previous section</a>; by default, many
Molt methods and functions return <code>Value</code> on success.</p>
<p>The <code>Exception</code> struct is used for all exceptional returns, including not only errors but also
procedure returns, loop breaks and continues, and application-specific result codes defined
as part of application-specific control structures.</p>
<p>The heart of the <code>Exception</code> struct is the <code>ResultCode</code>, which indicates the kind of
exception return. It is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum ResultCode {
    Okay,
    Error,
    Return,
    Break,
    Continue,
    Other(MoltInt),
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p><code>ResultCode::Okay</code> is used internally.</p>
</li>
<li>
<p><code>ResultCode::Error</code> indicates that an error has been thrown; the exception's
<code>value()</code> is the error message.  Use the exception's <code>error_code()</code> and
<code>error_info()</code> methods to access the error code and stack trace.</p>
</li>
<li>
<p><code>ResultCode::Return</code>, which indicates that the Molt code has called the
<code>return</code> command; the <code>value</code> is the returned value.  Molt procedures, defined using
the <code>proc</code> command, will catch this and return <code>value</code> as the value of the procedure call.
See the documentation for the <a href="embed/../ref/return.html"><strong>return</strong></a> and
<a href="embed/../ref/catch.html"><strong>catch</strong></a> commands for information on a variety of advanced things
that can be done using this result code.</p>
</li>
<li>
<p><code>ResultCode::Break</code> and <code>ResultCode::Continue</code> are returned by the <code>break</code> and
<code>continue</code> commands and control loop execution in the usual way.</p>
</li>
<li>
<p><code>ResultCode::Other</code> can be returned by the <a href="embed/../ref/return.html"><strong>return</strong></a> command, and is
used when defining application-specific control structures in script code.</p>
</li>
</ul>
<p>Of these, client Rust code will usually only deal with <code>ResultCode::Error</code> and
<code>ResultCode::Return</code>.  For example,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use molt::types::*;
</span><span class="boring">use molt::Interp;
</span>
let mut interp = Interp::new();

let input = "set a 1";

match interp.eval(input) {
   Ok(val) =&gt; {
       // Computed a Value
       println!("Value: {}", val);
   }
   Err(exception) =&gt; {
       if exception.is_error() {
           // Got an error; print it out.
           println!("Error: {}", exception.value());
       } else {
           // It's a Return.
           println!("Value: {}", exception.value());
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="result-macros"><a class="header" href="#result-macros">Result Macros</a></h2>
<p>Application-specific Rust code will usually only use <code>Ok(value)</code> and
<code>ResultCode::Error</code>. Since these two cases pop up so often,
Molt provides several macros to make them easier: <code>molt_ok!</code>, <code>molt_err!</code>,
and <code>molt_throw!</code>.</p>
<p><code>molt_ok!</code> takes one or more arguments and converts them into an <code>Ok(Value)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Returns the empty result.
return molt_ok!();

// Returns its argument as a Value (if Molt knows how to convert it)
return molt_ok!(5);

// A plain Value is OK to.
return molt_ok!(Value::from(5));

// Returns a formatted string as a Value using a Rust `format!` string.
return molt_ok!("The answer is {}.", x);
<span class="boring">}</span></code></pre></pre>
<p><code>molt_err!</code> works just the same way, but returns <code>Err(Exception)</code> with <code>ResultCode::Error</code>.</p>
<pre><code>// Return a simple error message
return molt_err!("error message");

// Return a formatted error message
if x &gt; 5 {
    return molt_err!("value is out of range: {}", x);
}
</code></pre>
<p><code>molt_throw!</code> is like <code>molt_err!</code>, but allows the caller to set an explicit error code.  (By
default, Molt errors have an error code of <code>NONE</code>.) Error codes can be retrieved from the
<code>Exception</code> object in Rust code and via the <a href="embed/../ref/catch.html"><strong>catch</strong></a> command in scripts.</p>
<pre><code>// Throw a simple error
return molt_throw!("MYCODE", "error message");

// Throw a formatted error message
if x &gt; 5 {
    return molt_throw!("MYCODE", "value is out of range: {}", x);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-commands"><a class="header" href="#defining-commands">Defining Commands</a></h1>
<p>At base, a Molt command is a Rust function that performs some kind of work and optionally
returns a value in the context of a specific Rust interpreter.  There are two ways an
application (or library crate) can define application-specific Rust commands:</p>
<ul>
<li>As a Rust <code>CommandFunc</code> function</li>
<li>As a Molt procedure, or <code>proc</code>.</li>
</ul>
<h2 id="commandfunc-commands"><a class="header" href="#commandfunc-commands"><code>CommandFunc</code> Commands</a></h2>
<p>A <code>CommandFunc</code> command is any Rust function that implements <code>CommandFunc</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type CommandFunc = fn(&amp;mut Interp, ContextID, &amp;[Value]) -&gt; MoltResult;
<span class="boring">}</span></code></pre></pre>
<p>For example, here's a simple command that takes one argument and returns it
unchanged.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cmd_ident(_interp: &amp;mut Interp, _context_id: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 2, "value")?;

    molt_ok!(argv[1].clone())
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>argv</code> vector contains the arguments to the command, beginning with the
command's name.  The <code>check_args</code> method verifies that the command has the right
number of arguments, and returns the standard Tcl error message if not.  Finally,
it uses <code>molt_ok!</code> to return its first argument.</p>
<p>Install this command into the interpreter using the <code>Interp::add_command</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>interp.add_command("ident", cmd_ident);
<span class="boring">}</span></code></pre></pre>
<h2 id="commandfunc-commands-with-context"><a class="header" href="#commandfunc-commands-with-context"><code>CommandFunc</code> Commands with Context</a></h2>
<p>A normal <code>CommandFunc</code> is useful when extending the Molt language itself; but
application-specific commands need to manipulate the application and its data.  In this case,
add the required data to the interpreter's <em>context cache</em>.  The cached data can be retrieved,
used, and mutated by commands tagged with the relevant context ID.</p>
<p>The context cache is a hash map that allows the interpreter to keep arbitrary data and make
it available to commands. The usual pattern is like this:</p>
<ul>
<li>
<p>The application defines a type containing the data the command (or commands) requires.
We'll call it <code>AppContext</code> for the purpose of this example.</p>
</li>
<li>
<p>The application saves an instance of <code>AppContext</code> into the context cache, retrieving a
<code>ContextID</code>.</p>
</li>
<li>
<p>The application includes the <code>ContextID</code> when adding the command to the interpreter.</p>
</li>
<li>
<p>The command retrieves the <code>AppContext</code> as a mutable borrow.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">// The AppContext
struct AppContext { text: String }

// The Command
fn cmd_whatsit(interp: &amp;mut Interp, context_id: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 2, "value")?;

    let ctx = interp.context::&lt;AppContext&gt;(context_id);

    // Append the first argument's string rep to the
    // AppContext struct's text field.
    ctx.text.push_str(argv[1].as_str());

    molt_ok!()
}

// Registering the command
fn main() {
    let interp = Interp::new();
    let id = interp.save_context(AppContext::new());

    interp.add_context_command("whatsit", cmd_whatsit, id);

    ...
}</code></pre></pre>
<p>The saved <code>AppContext</code> will be dropped automatically if the <code>whatsit</code> command is
removed from the interpreter.</p>
<h2 id="commands-with-shared-context"><a class="header" href="#commands-with-shared-context">Commands with Shared Context</a></h2>
<p>Any number of Molt commands can share a single cached context struct:</p>
<pre><code>    let interp = Interp::new();
    let id = interp.save_context(AppContext::new());

    interp.add_context_command("first", cmd_first, id);
    interp.add_context_command("second", cmd_second, id);
    interp.add_context_command("third", cmd_third, id);
    ...
</code></pre>
<p>The context struct will persist in the cache until the final command is removed (or, of
course, until the interpreter is dropped).</p>
<h2 id="molt-objects"><a class="header" href="#molt-objects">Molt Objects</a></h2>
<p>The standard way to represent an object in TCL is to define a command with attached
context data. The command's methods are implemented as subcommands.</p>
<p>The context cache supports this pattern trivially.  Define the object's instance variables
as a context struct, and define a command to create instances.</p>
<pre><code>// Instance Data
struct InstanceContext { text: String }

// Command to make an instance
fn cmd_make(interp: &amp;mut Interp, _: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 2, "name")?;

    let id = interp.save_context(InstanceContext::new());

    interp.add_context_command(argv[1].as_str(), cmd_instance, id);

    molt_ok!()
}

// Instance Command
fn cmd_instance(interp: &amp;mut Interp, _: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 0, "subcommand ?args...?")?;

    // Get the context
    let ctx = interp.context::&lt;AppContext&gt;(context_id);

    // Do stuff based on argv[1], the subcommand.
    ...
}

// Registering the command
fn main() {
    let interp = Interp::new();

    interp.add_command("make", cmd_make);

    ...
}
</code></pre>
<p>Then, in Molt code you can create an object called <code>fred</code>, use its methods, and then
destroy it by renaming it to the empty string.</p>
<pre><code class="language-tcl">% make fred
% fred do_something 1 2 3
...
% rename fred ""
</code></pre>
<h2 id="molt-procedures"><a class="header" href="#molt-procedures">Molt Procedures</a></h2>
<p>A Molt procedure is a routine coded in Tcl and defined using the <code>proc</code> command. A
crate can compile Tcl procedures into itself using the <code>include_str!</code> macro.  Start
by defining a script that defines the required procedure, say, <code>procs.tcl</code>, and put it
in the crate's <code>src/</code> folder adjacent to the Rust file that will load it.  The Rust
file can then do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut interp = Interp::new();

match interp.eval(include_str!("commands.tcl")) {
    Err(exception) =&gt; {
        if exception.is_error() {
            panic!("Couldn't load procs.tcl: {}", msg.value());
        }
    }
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluating-molt-code"><a class="header" href="#evaluating-molt-code">Evaluating Molt Code</a></h1>
<p>An application can evaluate Molt code in several ways:</p>
<ul>
<li>
<p>Use one of the <code>molt::Interp::eval</code> or <code>molt::Interp::eval_value</code> to evaluate an
individual Molt command or script.</p>
</li>
<li>
<p>Use the <code>molt::expr</code> function to evaluate a Molt expression, returning a Molt <code>Value</code>,
or <code>molt::expr_bool</code>, <code>molt::expr_int</code>, and <code>molt::expr_float</code> for results of specific
types.</p>
</li>
<li>
<p>Use the <code>molt_shell::repl</code> function to provide an interactive REPL to the user.</p>
</li>
<li>
<p>Use the <code>molt_shell::script</code> function to evaluate a script file (or just load the script's
content and pass it to <code>molt::Interp::eval</code>).</p>
</li>
</ul>
<h2 id="evaluating-scripts-with-eval"><a class="header" href="#evaluating-scripts-with-eval">Evaluating Scripts with <code>eval</code></a></h2>
<p>The <code>molt::Interp::eval</code> method evaluates a string as a Molt script and returns the
result.  When executed at the top level, <code>ResultCode::Break</code>, <code>ResultCode::Continue</code>,
and <code>ResultCode::Other</code> are converted to errors, just as they are in <code>proc</code> bodies. See
<a href="embed/./molt_result.html">The <code>MoltResult</code> Type</a> for details.)</p>
<p>Thus, the following code will execute a script, returning its value and propagating
any exceptions to the caller.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use molt::Interp;
use molt::types::*;

let mut interp = Interp::new();

...

let value: Value = interp.eval("...some Molt code...")?;
<span class="boring">}</span></code></pre></pre>
<p>The <code>molt::Interp::eval_value</code> method has identical semantics, but evaluates the string
representation of a molt <code>Value</code>. In this case, the <code>Value</code> will cache the parsed internal
form of the script to speed up subsequent evaluations.</p>
<h2 id="evaluating-control-structure-bodies"><a class="header" href="#evaluating-control-structure-bodies">Evaluating Control Structure Bodies</a></h2>
<p>The <code>molt::Interp::eval_value</code> method is used when implementing control structures.  For
example, this is an annotated version of of Molt's <a href="embed/./ref/while.html"><strong>while</strong></a> command.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cmd_while(interp: &amp;mut Interp, _: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 3, 3, "test command")?;

    // Here we evaluate the test expression as a boolean.  Any errors are propagated.
    while interp.expr_bool(&amp;argv[1])? {
        // Here we evaluate the loop's body.
        let result = interp.eval_value(&amp;argv[2]);

        if let Err(exception) = result {
            match exception.code() {
                // They want to break; so break out of the rust loop.
                ResultCode::Break =&gt; break,

                // They want to continue; so continue with the next iteration.
                ResultCode::Continue =&gt; (),

                // It's some other exception; just propagate it.
                _ =&gt; return Err(exception),
            }
        }
    }

    // All is good, so return Ok!
    molt_ok!()
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="embed/./molt_result.html">The <code>MoltResult</code> Type</a> for more information.</p>
<h2 id="evaluating-expressions-with-expr-and-expr_bool"><a class="header" href="#evaluating-expressions-with-expr-and-expr_bool">Evaluating Expressions with <code>expr</code> and <code>expr_bool</code>.</a></h2>
<p>Evaluating Molt expressions is similar.  To get any expression result (usually a
numeric or boolean <code>Value</code>), use the <code>Interp::expr</code> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use molt::Interp;
use molt::types::*;
use molt::expr;

let mut interp = Interp::new();

...

let value: Value = interp.expr("1 + 1")?;
<span class="boring">}</span></code></pre></pre>
<p>Use <code>Interp::expr_bool</code> when a specifically boolean result is wanted:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let flag: bool = interp.expr_bool("1 == 1")?;
<span class="boring">}</span></code></pre></pre>
<p>(See the <a href="embed/../ref/expr.html"><code>expr</code></a> command reference for more about Molt expressions.)</p>
<h2 id="providing-an-interactive-repl"><a class="header" href="#providing-an-interactive-repl">Providing an interactive REPL</a></h2>
<p>An interactive user shell or "REPL" (Read-Eval-Print-Loop) can be a great convenience
when developing and debugging application scripts; it can also be useful tool for
administering server processes.  To provide an interactive shell, use
the <code>molt_shell::repl</code> function.</p>
<pre><code>use molt::Interp;

// FIRST, create and initialize the interpreter.
let mut interp = Interp::new();

// NOTE: commands can be added to the interpreter here.

// NEXT, invoke the REPL.
molt_shell::repl(&amp;mut interp);
</code></pre>
<p>The REPL's prompt can be set using the <code>tcl_prompt1</code> variable to a script; see the
<a href="embed/../cmdline/molt_shell.html"><strong>molt shell</strong></a> documentation for an example.</p>
<h2 id="evaluating-script-files"><a class="header" href="#evaluating-script-files">Evaluating Script Files</a></h2>
<p>To execute a user script file, one can load the file contents and use <code>Interp::eval</code> in
the normal way, or use the <code>molt_shell::script</code> function.  A shell application might
execute a user script as follows.  Any errors are output to the console.</p>
<pre><code>use molt::Interp;
use std::env;

// FIRST, get the command line arguments.
let args: Vec&lt;String&gt; = env::args().collect();

// NEXT, create and initialize the interpreter.
let mut interp = Interp::new();

// NOTE: commands can be added to the interpreter here.

// NEXT, evaluate the file, if any.
if args.len() &gt; 1 {
    molt_shell::script(&amp;mut interp, &amp;args[1..]);
} else {
    eprintln!("Usage: myshell filename.tcl");
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-shells"><a class="header" href="#custom-shells">Custom Shells</a></h1>
<p>A custom Molt shell is simply an application that:</p>
<ul>
<li>Creates a Molt <code>interp</code></li>
<li>Adds any desired commands by the methods described in the previous section</li>
<li>Passes the <code>interp</code> to <code>molt_shell::repl</code> (for an interactive shell)</li>
<li>Passes the <code>interp</code> and a file to <code>molt_shell::script</code></li>
</ul>
<p>The <a href="https://github.com/wduquette/molt-sample">sample Molt application</a> provides a full
example; here's a sketch:</p>
<pre><code>fn main() {
    use std::env;

    // FIRST, get the command line arguments.
    let args: Vec&lt;String&gt; = env::args().collect();

    // NEXT, create and initialize the interpreter.
    let mut interp = Interp::new();

    // NOTE: commands can be added to the interpreter here, e.g.,

    // Add a single module
    interp.add_command("hello", cmd_hello);

    // Install a Molt extension crate
    molt_sample::install(&amp;mut interp).expect("Could not install.");

    // NEXT, evaluate the file, if any.
    if args.len() &gt; 1 {
        molt_shell::script(&amp;mut interp, &amp;args[1..]);
    } else {
        molt_shell::repl(&amp;mut interp);
    }
}

pub fn cmd_hello(_interp: &amp;mut Interp,  _: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    // Correct number of arguments?
    check_args(1, argv, 2, 2, "name")?;

    println!("Hello, {}", argv[1].as_str());
    molt_ok!()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="molt-library-crates"><a class="header" href="#molt-library-crates">Molt Library Crates</a></h1>
<p>A Molt library crate is simply a Rust crate that can install commands into a
Molt interpreter using any of the methods described in this chapter. For example,
a crate might provide an <code>install</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use molt::Interp

pub fn install(interp: &amp;mut Interp) {
    interp.add_command("mycommand", mycommand);
    ...
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
